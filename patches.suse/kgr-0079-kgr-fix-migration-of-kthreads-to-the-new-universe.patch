From: Miroslav Benes <mbenes@suse.cz>
Date: Tue, 6 Oct 2015 10:05:51 +0200
Subject: kgr: fix migration of kthreads to the new universe
Patch-mainline: submitted for review
References: fate#313296

Currently when all the slow stubs are applied all tasks in the system
are marked as being in progress of migration to the new universe. If the
task is a kthread it is immediately woken up with wake_up_process()
function in order to being migrated.

Unfortunately there is a problem with this approach. If the kthread
calls a patched function between its awakening and its call to
schedule() it appears in kgraft slow stub. There the redirection to
the correct function should happen. If kgr_immutable flag is set
(meaning that slow stub application is not finished yet during current
patching process) the task is marked as non-migrated and its
TIF_KGR_IN_PROGRESS flag is set again. This prevents certain races which
could cause corruption. The issue is that the flag could be cleared
earlier by the kthread itself and it is set again in the slow stub.  It
will not be in the future anymore. Such kthread would block the patching
process.

Fix it by moving wake_up_process() for all the kthreads after the
kgr_immutable is cleared.

Note that there is no corruption involved. It is by all means possible
that an affected kthread could wake up and clear its flag by itself.
However in general kthreads can block the patching process infinitely.

mb: renamed kgr_handle_processes() to kgr_mark_processes(). It makes
    sense again.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Reviewed-by: Petr Mladek <pmladek@suse.com>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/kgraft.c |   36 +++++++++++++++++++++++++++++-------
 1 file changed, 29 insertions(+), 7 deletions(-)

--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -324,15 +324,31 @@ void kgr_unmark_processes(void)
 	read_unlock(&tasklist_lock);
 }
 
-static void kgr_handle_processes(void)
+static void kgr_mark_processes(void)
 {
 	struct task_struct *p, *t;
 
 	read_lock(&tasklist_lock);
-	for_each_process_thread(p, t) {
+	for_each_process_thread(p, t)
 		kgr_mark_task_in_progress(t);
-		/* wake up kthreads, they will clean the progress flag */
-		if (t->flags & PF_KTHREAD) {
+	read_unlock(&tasklist_lock);
+}
+
+static void kgr_wakeup_kthreads(void)
+{
+	struct task_struct *p, *t;
+
+	read_lock(&tasklist_lock);
+	for_each_process_thread(p, t) {
+		/*
+		 * Wake up kthreads, they will clean the progress flag.
+		 *
+		 * There is a small race here. We could see TIF_KGR_IN_PROGRESS
+		 * set and decide to wake up a kthread. Meanwhile the kthread
+		 * could migrate itself and the waking up would be meaningless.
+		 * It is not serious though.
+		 */
+		if ((t->flags & PF_KTHREAD) && kgr_task_in_progress(t)) {
 			/*
 			 * this is incorrect for kthreads waiting still for
 			 * their first wake_up.
@@ -913,7 +929,7 @@ int kgr_modify_kernel(struct kgr_patch *
 	}
 
 	set_bit(0, kgr_immutable);
-	wmb(); /* set_bit before kgr_handle_processes */
+	wmb(); /* set_bit before kgr_mark_processes */
 
 	/*
 	 * Set kgr_patch before it can be used in kgr_patching_failed if
@@ -951,10 +967,16 @@ int kgr_modify_kernel(struct kgr_patch *
 	mutex_unlock(&kgr_in_progress_lock);
 
 	kgr_handle_irqs();
-	kgr_handle_processes();
-	wmb(); /* clear_bit after kgr_handle_processes */
+	kgr_mark_processes();
+	wmb(); /* clear_bit after kgr_mark_processes */
 	clear_bit(0, kgr_immutable);
 	/*
+	 * There is no need to have an explicit barrier here. wake_up_process()
+	 * implies a write barrier. That is every woken up task sees
+	 * kgr_immutable cleared.
+	 */
+	kgr_wakeup_kthreads();
+	/*
 	 * give everyone time to exit kernel, and check after a while
 	 */
 	queue_delayed_work(kgr_wq, &kgr_work, KGR_TIMEOUT * HZ);
