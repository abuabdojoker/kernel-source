From: Jiri Slaby <jslaby@suse.cz>
Date: Wed, 6 May 2015 15:54:04 +0200
Subject: kgr: use for_each_process_thread
Patch-mainline: submitted for review
References: fate#313296 bnc#929883

for_each_process walks only through group leaders. Iterate over all
tasks in the system using for_each_process_thread.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Reported-by: Oleg Nesterov <oleg@redhat.com>
---
 kernel/kgraft.c |   25 +++++++++++++------------
 1 file changed, 13 insertions(+), 12 deletions(-)

--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -143,16 +143,17 @@ static int kgr_ftrace_disable(struct kgr
 
 static bool kgr_still_patching(void)
 {
-	struct task_struct *p;
+	struct task_struct *p, *t;
 	bool failed = false;
 
 	read_lock(&tasklist_lock);
-	for_each_process(p) {
-		if (kgr_task_in_progress(p)) {
+	for_each_process_thread(p, t) {
+		if (kgr_task_in_progress(t)) {
 			failed = true;
-			break;
+			goto unlock;
 		}
 	}
+unlock:
 	read_unlock(&tasklist_lock);
 	return failed;
 }
@@ -293,28 +294,28 @@ static void kgr_work_fn(struct work_stru
 
 void kgr_unmark_processes(void)
 {
-	struct task_struct *p;
+	struct task_struct *p, *t;
 
 	read_lock(&tasklist_lock);
-	for_each_process(p)
-		kgr_task_safe(p);
+	for_each_process_thread(p, t)
+		kgr_task_safe(t);
 	read_unlock(&tasklist_lock);
 }
 
 static void kgr_handle_processes(void)
 {
-	struct task_struct *p;
+	struct task_struct *p, *t;
 
 	read_lock(&tasklist_lock);
-	for_each_process(p) {
-		kgr_mark_task_in_progress(p);
+	for_each_process_thread(p, t) {
+		kgr_mark_task_in_progress(t);
 		/* wake up kthreads, they will clean the progress flag */
-		if (p->flags & PF_KTHREAD) {
+		if (t->flags & PF_KTHREAD) {
 			/*
 			 * this is incorrect for kthreads waiting still for
 			 * their first wake_up.
 			 */
-			wake_up_process(p);
+			wake_up_process(t);
 		}
 	}
 	read_unlock(&tasklist_lock);
