From: Jiri Slaby <jslaby@suse.cz>
Date: Wed, 29 Jan 2014 18:22:39 +0100
Subject: kgr: mark task_safe in some kthreads
Patch-mainline: submitted for review
References: fate#313296 bnc#889207 bnc#891710

Before we enable a kthread support in kGraft, we must make sure all
kthreads mark themselves as kGraft-safe at some point explicitly.

We do this by injecting kgr_task_safe to the freezer test. There, we
assume that kthreads are in some predefined state and can expect
something bad to happen. Hence we switch the kGraft worlds there from
the old one to the new one. The optimal solution would be to convert
most of kthreads (that need not be kthreads actually) to workqeues as
suggested by Tejun. This is an upcoming work that will appear next.
But until we get there, we use freezer for kGraft that way as is
presented here.

Note that there are also some kthreads that do not utilize freezer, so
we use kgr_task_safe in them explicitly. This happens at locations
that appear to be safe for the kthreads to switch the worlds.

The end result after we migrate kthreads (that need not be kthreads)
to workqueues is: have only kthreads that contain kgr_task_safe
explicitly (or using some helper) and nothing else.

jk: issue kgr_task_safe() for !CONFIG_FREEZER
jk: call kgr_task_safe only for kthreads in fix try_to_freeze
js: one line, one command

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org> [devtmpfs]
Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com> [rcu]
Cc: Steven Rostedt <rostedt@goodmis.org>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Ingo Molnar <mingo@redhat.com>
Cc: "Theodore Ts'o" <tytso@mit.edu>
Cc: Dipankar Sarma <dipankar@in.ibm.com>
Cc: Tejun Heo <tj@kernel.org>
---
 drivers/base/devtmpfs.c          |    1 +
 drivers/char/ipmi/ipmi_si_intf.c |    2 ++
 drivers/scsi/scsi_error.c        |    2 ++
 drivers/usb/core/hub.c           |    4 ++--
 drivers/virtio/virtio_balloon.c  |    5 +++--
 fs/jbd2/journal.c                |    2 ++
 fs/notify/mark.c                 |    5 ++++-
 fs/xfs/xfs_trans_ail.c           |    2 ++
 include/linux/freezer.h          |   11 ++++++++++-
 kernel/hung_task.c               |    5 ++++-
 kernel/irq/manage.c              |    1 +
 kernel/kthread.c                 |    3 +++
 kernel/rcutree.c                 |    6 ++++--
 kernel/rcutree_plugin.h          |   10 ++++++++--
 kernel/smpboot.c                 |    2 ++
 kernel/workqueue.c               |    3 +++
 mm/huge_memory.c                 |    6 ++++--
 mm/ksm.c                         |    5 +++--
 net/bluetooth/rfcomm/core.c      |    2 ++
 19 files changed, 62 insertions(+), 15 deletions(-)

--- a/drivers/base/devtmpfs.c
+++ b/drivers/base/devtmpfs.c
@@ -387,6 +387,7 @@ static int devtmpfsd(void *p)
 	sys_chroot(".");
 	complete(&setup_done);
 	while (1) {
+		kgr_task_safe(current);
 		spin_lock(&req_lock);
 		while (requests) {
 			struct req *req = requests;
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -1012,6 +1012,8 @@ static int ipmi_thread(void *data)
 	while (!kthread_should_stop()) {
 		int busy_wait;
 
+		kgr_task_safe(current);
+
 		spin_lock_irqsave(&(smi_info->si_lock), flags);
 		smi_result = smi_event_handler(smi_info, 0);
 
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -2180,6 +2180,8 @@ int scsi_error_handler(void *data)
 	 * disables signal delivery for the created thread.
 	 */
 	while (true) {
+		kgr_task_safe(current);
+
 		/*
 		 * The sequence in kthread_stop() sets the stop flag first
 		 * then wakes the process.  To avoid missed wakeups, the task
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5142,9 +5142,9 @@ static int hub_thread(void *__unused)
 
 	do {
 		hub_events();
-		wait_event_freezable(khubd_wait,
+		wait_event_freezable(khubd_wait, ({ kgr_task_safe(current);
 				!list_empty(&hub_event_list) ||
-				kthread_should_stop());
+				kthread_should_stop(); }));
 	} while (!kthread_should_stop() || !list_empty(&hub_event_list));
 
 	pr_debug("%s: khubd exiting\n", usbcore_name);
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@ -300,11 +300,12 @@ static int balloon(void *_vballoon)
 		s64 diff;
 
 		try_to_freeze();
-		wait_event_interruptible(vb->config_change,
+		wait_event_interruptible(vb->config_change, ({
+					 kgr_task_safe(current);
 					 (diff = towards_target(vb)) != 0
 					 || vb->need_stats_update
 					 || kthread_should_stop()
-					 || freezing(current));
+					 || freezing(current); }));
 		if (vb->need_stats_update)
 			stats_handle_request(vb);
 		if (diff > 0)
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -43,6 +43,7 @@
 #include <linux/backing-dev.h>
 #include <linux/bitops.h>
 #include <linux/ratelimit.h>
+#include <linux/sched.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/jbd2.h>
@@ -260,6 +261,7 @@ loop:
 			write_lock(&journal->j_state_lock);
 		}
 		finish_wait(&journal->j_wait_commit, &wait);
+		kgr_task_safe(current);
 	}
 
 	jbd_debug(1, "kjournald2 wakes\n");
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -82,6 +82,7 @@
 #include <linux/kthread.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/srcu.h>
@@ -375,7 +376,9 @@ static int fsnotify_mark_destroy(void *i
 			fsnotify_put_mark(mark);
 		}
 
-		wait_event_interruptible(destroy_waitq, !list_empty(&destroy_list));
+		wait_event_interruptible(destroy_waitq, ({
+					kgr_task_safe(current);
+					!list_empty(&destroy_list); }));
 	}
 
 	return 0;
--- a/fs/xfs/xfs_trans_ail.c
+++ b/fs/xfs/xfs_trans_ail.c
@@ -500,6 +500,8 @@ xfsaild(
 	current->flags |= PF_MEMALLOC;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		if (tout && tout <= 20)
 			__set_current_state(TASK_KILLABLE);
 		else
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -61,6 +61,9 @@ static inline bool try_to_freeze_unsafe(
 
 static inline bool try_to_freeze(void)
 {
+	if (current->flags & PF_KTHREAD)
+		kgr_task_safe(current);
+
 	if (!(current->flags & PF_NOFREEZE))
 		debug_check_no_locks_held();
 	return try_to_freeze_unsafe();
@@ -316,7 +319,13 @@ static inline void thaw_processes(void)
 static inline void thaw_kernel_threads(void) {}
 
 static inline bool try_to_freeze_nowarn(void) { return false; }
-static inline bool try_to_freeze(void) { return false; }
+static inline bool try_to_freeze(void)
+{
+	if (current->flags & PF_KTHREAD)
+		kgr_task_safe(current);
+
+	return false;
+}
 
 static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}
--- a/kernel/hung_task.c
+++ b/kernel/hung_task.c
@@ -14,6 +14,7 @@
 #include <linux/kthread.h>
 #include <linux/lockdep.h>
 #include <linux/export.h>
+#include <linux/sched.h>
 #include <linux/sysctl.h>
 #include <linux/utsname.h>
 
@@ -213,8 +214,10 @@ static int watchdog(void *dummy)
 	for ( ; ; ) {
 		unsigned long timeout = sysctl_hung_task_timeout_secs;
 
-		while (schedule_timeout_interruptible(timeout_jiffies(timeout)))
+		while (schedule_timeout_interruptible(timeout_jiffies(timeout))) {
+			kgr_task_safe(current);
 			timeout = sysctl_hung_task_timeout_secs;
+		}
 
 		check_hung_uninterruptible_tasks(timeout);
 	}
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -653,6 +653,7 @@ static int irq_wait_for_interrupt(struct
 	set_current_state(TASK_INTERRUPTIBLE);
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 
 		if (test_and_clear_bit(IRQTF_RUNTHREAD,
 				       &action->thread_flags)) {
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -112,6 +112,8 @@ bool kthread_freezable_should_stop(bool
 {
 	bool frozen = false;
 
+	kgr_task_safe(current);
+
 	might_sleep();
 
 	if (unlikely(freezing(current)))
@@ -484,6 +486,7 @@ int kthreadd(void *unused)
 		if (list_empty(&kthread_create_list))
 			schedule();
 		__set_current_state(TASK_RUNNING);
+		kgr_task_safe(current);
 
 		spin_lock(&kthread_create_lock);
 		while (!list_empty(&kthread_create_list)) {
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@ -1522,9 +1522,10 @@ static int __noreturn rcu_gp_kthread(voi
 
 		/* Handle grace-period start. */
 		for (;;) {
-			wait_event_interruptible(rsp->gp_wq,
+			wait_event_interruptible(rsp->gp_wq, ({
+						 kgr_task_safe(current);
 						 rsp->gp_flags &
-						 RCU_GP_FLAG_INIT);
+						 RCU_GP_FLAG_INIT; }));
 			if ((rsp->gp_flags & RCU_GP_FLAG_INIT) &&
 			    rcu_gp_init(rsp))
 				break;
@@ -1546,6 +1547,7 @@ static int __noreturn rcu_gp_kthread(voi
 					(!ACCESS_ONCE(rnp->qsmask) &&
 					 !rcu_preempt_blocked_readers_cgp(rnp)),
 					j);
+			kgr_task_safe(current);
 			/* If grace period done, leave loop. */
 			if (!ACCESS_ONCE(rnp->qsmask) &&
 			    !rcu_preempt_blocked_readers_cgp(rnp))
--- a/kernel/rcutree_plugin.h
+++ b/kernel/rcutree_plugin.h
@@ -27,6 +27,7 @@
 #include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/oom.h>
+#include <linux/sched.h>
 #include <linux/smpboot.h>
 #include "time/tick-internal.h"
 
@@ -1252,7 +1253,8 @@ static int rcu_boost_kthread(void *arg)
 	for (;;) {
 		rnp->boost_kthread_status = RCU_KTHREAD_WAITING;
 		trace_rcu_utilization(TPS("End boost kthread@rcu_wait"));
-		rcu_wait(rnp->boost_tasks || rnp->exp_tasks);
+		rcu_wait(({ kgr_task_safe(current);
+					rnp->boost_tasks || rnp->exp_tasks; }));
 		trace_rcu_utilization(TPS("Start boost kthread@rcu_wait"));
 		rnp->boost_kthread_status = RCU_KTHREAD_RUNNING;
 		more2boost = rcu_boost(rnp);
@@ -2236,9 +2238,13 @@ static int rcu_nocb_kthread(void *arg)
 
 	/* Each pass through this loop invokes one batch of callbacks */
 	for (;;) {
+		kgr_task_safe(current);
+
 		/* If not polling, wait for next batch of callbacks. */
 		if (!rcu_nocb_poll)
-			wait_event_interruptible(rdp->nocb_wq, rdp->nocb_head);
+			wait_event_interruptible(rdp->nocb_wq, ({
+						 kgr_task_safe(current);
+						 rdp->nocb_head; }));
 		list = ACCESS_ONCE(rdp->nocb_head);
 		if (!list) {
 			schedule_timeout_interruptible(1);
--- a/kernel/smpboot.c
+++ b/kernel/smpboot.c
@@ -107,6 +107,8 @@ static int smpboot_thread_fn(void *data)
 	struct smp_hotplug_thread *ht = td->ht;
 
 	while (1) {
+		kgr_task_safe(current);
+
 		set_current_state(TASK_INTERRUPTIBLE);
 		preempt_disable();
 		if (kthread_should_stop()) {
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -2367,6 +2367,7 @@ sleep:
 	__set_current_state(TASK_INTERRUPTIBLE);
 	spin_unlock_irq(&pool->lock);
 	schedule();
+	kgr_task_safe(current);
 	goto woke_up;
 }
 
@@ -2408,6 +2409,8 @@ static int rescuer_thread(void *__rescue
 repeat:
 	set_current_state(TASK_INTERRUPTIBLE);
 
+	kgr_task_safe(current);
+
 	/*
 	 * By the time the rescuer is requested to stop, the workqueue
 	 * shouldn't have any work pending, but @wq->maydays may still have
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -2784,6 +2784,7 @@ static void khugepaged_do_scan(void)
 			break;
 
 		cond_resched();
+		kgr_task_safe(current);
 
 		if (unlikely(kthread_should_stop() || freezing(current)))
 			break;
@@ -2812,8 +2813,9 @@ static void khugepaged_wait_work(void)
 		if (!khugepaged_scan_sleep_millisecs)
 			return;
 
-		wait_event_freezable_timeout(khugepaged_wait,
-					     kthread_should_stop(),
+		wait_event_freezable_timeout(khugepaged_wait, ({
+					kgr_task_safe(current);
+					     kthread_should_stop(); }),
 			msecs_to_jiffies(khugepaged_scan_sleep_millisecs));
 		return;
 	}
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -1728,8 +1728,9 @@ static int ksm_scan_thread(void *nothing
 			schedule_timeout_interruptible(
 				msecs_to_jiffies(ksm_thread_sleep_millisecs));
 		} else {
-			wait_event_freezable(ksm_thread_wait,
-				ksmd_should_run() || kthread_should_stop());
+			wait_event_freezable(ksm_thread_wait, ({
+				kgr_task_safe(current);
+				ksmd_should_run() || kthread_should_stop(); }));
 		}
 	}
 	return 0;
--- a/net/bluetooth/rfcomm/core.c
+++ b/net/bluetooth/rfcomm/core.c
@@ -2045,6 +2045,8 @@ static int rfcomm_run(void *unused)
 		if (kthread_should_stop())
 			break;
 
+		kgr_task_safe(current);
+
 		/* Process stuff */
 		rfcomm_process_sessions();
 
