From: Jiri Slaby <jslaby@suse.cz>
Date: Thu, 21 Aug 2014 15:03:08 +0200
Subject: kgr: fix ugly race
Patch-mainline: submitted for review
References: fate#313296

The code contains an ugly race. If you are familiar with this notion:
(kgr_mark_processes . for_each_patch(kgr_patch_code)) || kgr_mark_safe

I.e. informally, when we set the in_progress bit for a process, it can
immediately clear the flag, but still calls the old function, because
we have not installed the slow stub via kgr_patch_code yet. When we
suddenly install it, the process can be in the middle of something
(and not safe to switch at all).

To fix that, we have to introduce a three-state logic:
* old-world-immutable
* old-world
* new-world

This is accomplished by introducing an atomic bit which we set prior
marking processes (old-world-immutable state) and clear after
installing the slow stub (old-world state). The slow stub always
re-sets the in_progress flag to 1 when in the old-world-immutable
universe. So only the exit from the syscall allows the switch to the
new-world.

jk: describe kgr_immutable
js: {
	Fix the race properly.

	First, set_bit before mark_processes, because this avoid race
	between them and slow stub.

	Second, merge kgr_mark_processes into kgr_handle_processes.
	Hence do the stuff after the stub is in place. This avoids
	another race.

	Finally, add memory barriers to force the consistent state.
	This is needed because, set_bit et al. are not implicit
	barriers (on non-x86 HW at least).

	Reported-by: Li Bin <huawei.libin@huawei.com>
}

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Cc: Vojtech Pavlik <vojtech@suse.cz>
Cc: Petr Mladek <pmladek@suse.cz>
---
 kernel/kgraft.c |   37 ++++++++++++++++++++++++-------------
 1 file changed, 24 insertions(+), 13 deletions(-)

--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -14,6 +14,7 @@
  * any later version.
  */
 
+#include <linux/bitmap.h>
 #include <linux/ftrace.h>
 #include <linux/hardirq.h> /* for in_interrupt() */
 #include <linux/kallsyms.h>
@@ -41,6 +42,16 @@ bool kgr_in_progress;
 static bool kgr_initialized;
 static struct kgr_patch *kgr_patch;
 static bool kgr_revert;
+/*
+ * Setting the per-process flag and stub instantiation has to be performed
+ * "atomically", otherwise the flag might get cleared and old function called
+ * during the race window.
+ *
+ * kgr_immutable is an atomic flag which signals whether we are in the
+ * actual race window and lets the stub take a proper action (reset the
+ * 'in progress' state)
+ */
+static DECLARE_BITMAP(kgr_immutable, 1);
 
 /*
  * The stub needs to modify the RIP value stored in struct pt_regs
@@ -63,8 +74,13 @@ static void kgr_stub_slow(unsigned long
 
 	if (in_interrupt())
 		go_old = !*this_cpu_ptr(p->patch->irq_use_new);
-	else
+	else if (test_bit(0, kgr_immutable)) {
+		kgr_mark_task_in_progress(current);
+		go_old = true;
+	} else {
+		rmb(); /* test_bit before kgr_mark_task_in_progress */
 		go_old = kgr_task_in_progress(current);
+	}
 
 	if (p->state == KGR_PATCH_REVERT_SLOW)
 		go_old = !go_old;
@@ -251,22 +267,13 @@ static void kgr_work_fn(struct work_stru
 	kgr_finalize();
 }
 
-static void kgr_mark_processes(void)
-{
-	struct task_struct *p;
-
-	read_lock(&tasklist_lock);
-	for_each_process(p)
-		kgr_mark_task_in_progress(p);
-	read_unlock(&tasklist_lock);
-}
-
 static void kgr_handle_processes(void)
 {
 	struct task_struct *p;
 
 	read_lock(&tasklist_lock);
 	for_each_process(p) {
+		kgr_mark_task_in_progress(p);
 		/* wake up kthreads, they will clean the progress flag */
 		if (p->flags & PF_KTHREAD) {
 			/*
@@ -555,8 +562,10 @@ int kgr_modify_kernel(struct kgr_patch *
 	 * If the patch has immediate flag set, avoid the lazy-switching
 	 * between universes completely.
 	 */
-	if (!patch->immediate)
-		kgr_mark_processes();
+	if (!patch->immediate) {
+		set_bit(0, kgr_immutable);
+		wmb(); /* set_bit before kgr_handle_processes */
+	}
 
 	kgr_for_each_patch_fun(patch, patch_fun) {
 		patch_fun->patch = patch;
@@ -591,6 +600,8 @@ int kgr_modify_kernel(struct kgr_patch *
 		kgr_finalize();
 	} else {
 		kgr_handle_processes();
+		wmb(); /* clear_bit after kgr_handle_processes */
+		clear_bit(0, kgr_immutable);
 		/*
 		 * give everyone time to exit kernel, and check after a while
 		 */
