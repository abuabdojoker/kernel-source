From: Miroslav Benes <mbenes@suse.cz>
Subject: kgr: add kgraft annotations to kthreads' wait_event_freezable() API calls
Patch-mainline: no, SLE12 specific
References: fate#313296

Kthreads calling wait_event_freezable() and similar API functions can
block finalization of the patching for a long time.
wait_event_freezable() eventually calls annotated try_to_freeze(), but
only after being woken up. Fix it by making kgr_task_safe() part of the
condition which wait_event_freezable() checks.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Reviewed-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/char/apm-emulation.c     |  5 +++--
 drivers/char/virtio_console.c    | 10 ++++++----
 drivers/dma/dmatest.c            |  4 +++-
 drivers/staging/android/binder.c |  8 ++++++--
 drivers/staging/keucr/usb.c      |  5 +++--
 fs/cifs/transport.c              |  5 +++--
 fs/ecryptfs/kthread.c            |  5 +++--
 mm/huge_memory.c                 |  7 +++++--
 8 files changed, 32 insertions(+), 17 deletions(-)

diff --git a/drivers/char/apm-emulation.c b/drivers/char/apm-emulation.c
index 12ef817..c12149c 100644
--- a/drivers/char/apm-emulation.c
+++ b/drivers/char/apm-emulation.c
@@ -300,8 +300,9 @@ apm_ioctl(struct file *filp, u_int cmd, u_long arg)
 			 * signal can cause busy looping.  We aren't doing
 			 * anything critical, chill a bit on each iteration.
 			 */
-			while (wait_event_freezable(apm_suspend_waitqueue,
-					as->suspend_state != SUSPEND_ACKED))
+			while (wait_event_freezable(apm_suspend_waitqueue, ({
+					kgr_task_safe(current);
+					as->suspend_state != SUSPEND_ACKED; })))
 				msleep(10);
 			break;
 		case SUSPEND_ACKTO:
diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c
index f6b96ba..6fb016b 100644
--- a/drivers/char/virtio_console.c
+++ b/drivers/char/virtio_console.c
@@ -765,8 +765,9 @@ static ssize_t port_fops_read(struct file *filp, char __user *ubuf,
 		if (filp->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 
-		ret = wait_event_freezable(port->waitqueue,
-					   !will_read_block(port));
+		ret = wait_event_freezable(port->waitqueue, ({
+					   kgr_task_safe(current);
+					   !will_read_block(port); }));
 		if (ret < 0)
 			return ret;
 	}
@@ -797,8 +798,9 @@ static int wait_port_writable(struct port *port, bool nonblock)
 		if (nonblock)
 			return -EAGAIN;
 
-		ret = wait_event_freezable(port->waitqueue,
-					   !will_write_block(port));
+		ret = wait_event_freezable(port->waitqueue, ({
+					   kgr_task_safe(current);
+					   !will_write_block(port); }));
 		if (ret < 0)
 			return ret;
 	}
diff --git a/drivers/dma/dmatest.c b/drivers/dma/dmatest.c
index f7fd814..6cd7d11 100644
--- a/drivers/dma/dmatest.c
+++ b/drivers/dma/dmatest.c
@@ -723,7 +723,9 @@ static int dmatest_func(void *data)
 		}
 		dma_async_issue_pending(chan);
 
-		wait_event_freezable_timeout(done_wait, done.done,
+		wait_event_freezable_timeout(done_wait, ({
+					     kgr_task_safe(current);
+					     done.done; }),
 					     msecs_to_jiffies(params->timeout));
 
 		status = dma_async_is_tx_complete(chan, cookie, NULL, NULL);
diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 69fd236..e1d5664 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -2141,13 +2141,17 @@ retry:
 			if (!binder_has_proc_work(proc, thread))
 				ret = -EAGAIN;
 		} else
-			ret = wait_event_freezable_exclusive(proc->wait, binder_has_proc_work(proc, thread));
+			ret = wait_event_freezable_exclusive(proc->wait, ({
+					kgr_task_safe(current);
+					binder_has_proc_work(proc, thread); }));
 	} else {
 		if (non_block) {
 			if (!binder_has_thread_work(thread))
 				ret = -EAGAIN;
 		} else
-			ret = wait_event_freezable(thread->wait, binder_has_thread_work(thread));
+			ret = wait_event_freezable(thread->wait, ({
+						   kgr_task_safe(current);
+						   binder_has_thread_work(thread); }));
 	}
 
 	binder_lock(__func__);
diff --git a/drivers/staging/keucr/usb.c b/drivers/staging/keucr/usb.c
index ddd2e73..519f3dc 100644
--- a/drivers/staging/keucr/usb.c
+++ b/drivers/staging/keucr/usb.c
@@ -503,8 +503,9 @@ static int usb_stor_scan_thread(void *__us)
 	set_freezable();
 	/* Wait for the timeout to expire or for a disconnect */
 	if (delay_use > 0) {
-		wait_event_freezable_timeout(us->delay_wait,
-				test_bit(US_FLIDX_DONT_SCAN, &us->dflags),
+		wait_event_freezable_timeout(us->delay_wait, ({
+				kgr_task_safe(current);
+				test_bit(US_FLIDX_DONT_SCAN, &us->dflags); }),
 				delay_use * HZ);
 	}
 
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index 800b938..03a4a68 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -452,8 +452,9 @@ wait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)
 {
 	int error;
 
-	error = wait_event_freezekillable_unsafe(server->response_q,
-				    midQ->mid_state != MID_REQUEST_SUBMITTED);
+	error = wait_event_freezekillable_unsafe(server->response_q, ({
+				    kgr_task_safe(current);
+				    midQ->mid_state != MID_REQUEST_SUBMITTED; }));
 	if (error < 0)
 		return -ERESTARTSYS;
 
diff --git a/fs/ecryptfs/kthread.c b/fs/ecryptfs/kthread.c
index f1ea610..38917ba 100644
--- a/fs/ecryptfs/kthread.c
+++ b/fs/ecryptfs/kthread.c
@@ -60,9 +60,10 @@ static int ecryptfs_threadfn(void *ignored)
 		struct ecryptfs_open_req *req;
 
 		wait_event_freezable(
-			ecryptfs_kthread_ctl.wait,
+			ecryptfs_kthread_ctl.wait, ({
+			kgr_task_safe(current);
 			(!list_empty(&ecryptfs_kthread_ctl.req_list)
-			 || kthread_should_stop()));
+			 || kthread_should_stop()); }));
 		mutex_lock(&ecryptfs_kthread_ctl.mux);
 		if (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {
 			mutex_unlock(&ecryptfs_kthread_ctl.mux);
diff --git a/mm/huge_memory.c b/mm/huge_memory.c
index cce30ab..f2d89e0 100644
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -2266,7 +2266,8 @@ static void __collapse_huge_page_copy(pte_t *pte, struct page *page,
 
 static void khugepaged_alloc_sleep(void)
 {
-	wait_event_freezable_timeout(khugepaged_wait, false,
+	wait_event_freezable_timeout(khugepaged_wait,
+			({ kgr_task_safe(current); false; }),
 			msecs_to_jiffies(khugepaged_alloc_sleep_millisecs));
 }
 
@@ -2822,7 +2823,9 @@ static void khugepaged_wait_work(void)
 	}
 
 	if (khugepaged_enabled())
-		wait_event_freezable(khugepaged_wait, khugepaged_wait_event());
+		wait_event_freezable(khugepaged_wait, ({
+					kgr_task_safe(current);
+					khugepaged_wait_event(); }));
 }
 
 static int khugepaged(void *none)
-- 
2.1.4

