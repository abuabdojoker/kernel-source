From: Miroslav Benes <mbenes@suse.cz>
Date: Tue, 6 Oct 2015 10:05:52 +0200
Subject: kgr: wake up kthreads periodically
Patch-mainline: submitted for review
References: fate#313296

We call wake_up_process() for kthreads only once during the patching (or
after it to be precise). Unfortunately this is not sufficient. A kthread
is marked as non-migrated (its TIF_KGR_IN_PROGRESS is set) and
wake_up_process() is called on this kthread after the patching. However
if the kthread is running, wake_up_process() has no effect and the
kthread can go to sleep without a call to kgr_task_safe(). Thus the
kthread would block the patching process from finishing till it is woken
up again by some other process than kgraft. We can fix this by calling
wake_up_process() periodically in the same way we do it with sending a
fake signal.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Reviewed-by: Petr Mladek <pmladek@suse.com>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/kgraft.c |   29 +++++++++++++++++++++--------
 1 file changed, 21 insertions(+), 8 deletions(-)

--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -274,16 +274,29 @@ static void kgr_send_fake_signal(void)
 
 	read_lock(&tasklist_lock);
 	for_each_process_thread(p, t) {
-		/*
-		 * send fake signal to all non-kthread tasks which are still
-		 * not migrated. kthreads should be migrated now.
-		 */
-		if ((t->flags & PF_KTHREAD) || !kgr_task_in_progress(t))
+		if (!kgr_task_in_progress(t))
 			continue;
 
-		spin_lock_irq(&t->sighand->siglock);
-		signal_wake_up(t, 0);
-		spin_unlock_irq(&t->sighand->siglock);
+		/*
+		 * There is a small race here. We could see TIF_KGR_IN_PROGRESS
+		 * set and decide to wake up a kthread or send a fake signal.
+		 * Meanwhile the thread could migrate itself and the action
+		 * would be meaningless.  It is not serious though.
+		 */
+		if (t->flags & PF_KTHREAD) {
+			/*
+			 * Wake up a kthread which still has not been migrated.
+			 */
+			wake_up_process(t);
+		} else {
+			/*
+			 * Send fake signal to all non-kthread tasks which are
+			 * still not migrated.
+			 */
+			spin_lock_irq(&t->sighand->siglock);
+			signal_wake_up(t, 0);
+			spin_unlock_irq(&t->sighand->siglock);
+		}
 	}
 	read_unlock(&tasklist_lock);
 }
