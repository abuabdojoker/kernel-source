From: Jiri Slaby <jslaby@suse.cz>
Date: Fri, 14 Nov 2014 16:13:22 +0100
Subject: kgr: mark even more kthreads
Patch-mainline: submitted for review
References: fate#313296 bnc#905087 bnc#906140

They are not using freezer or are not marked by kgr_task_safe yet.
These kthreads, if not annotated, would prevent kgraft from finishing.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 arch/arm/mach-rpc/ecard.c                              |    3 -
 arch/powerpc/kernel/eeh_event.c                        |    2 
 arch/powerpc/platforms/44x/warp.c                      |    1 
 arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c         |    1 
 arch/powerpc/platforms/83xx/suspend.c                  |    3 -
 arch/powerpc/platforms/cell/spufs/sched.c              |    1 
 arch/powerpc/platforms/ps3/device-init.c               |    5 +
 arch/powerpc/platforms/pseries/cmm.c                   |    1 
 arch/s390/mm/cmm.c                                     |    5 +
 arch/sparc/kernel/ds.c                                 |    1 
 arch/x86/kernel/apm_32.c                               |    1 
 arch/x86/mm/pageattr-test.c                            |    1 
 drivers/block/aoe/aoecmd.c                             |    1 
 drivers/block/cciss.c                                  |    2 
 drivers/block/loop.c                                   |    5 +
 drivers/block/mtip32xx/mtip32xx.c                      |    6 +-
 drivers/block/nbd.c                                    |    5 +
 drivers/block/nvme-core.c                              |    1 
 drivers/bluetooth/btmrvl_main.c                        |    1 
 drivers/char/apm-emulation.c                           |    4 -
 drivers/char/hw_random/core.c                          |    1 
 drivers/crypto/mv_cesa.c                               |    2 
 drivers/dma/dmatest.c                                  |    2 
 drivers/hv/hv_balloon.c                                |    2 
 drivers/hwmon/adt7470.c                                |    2 
 drivers/infiniband/core/fmr_pool.c                     |    2 
 drivers/infiniband/hw/nes/nes_mgt.c                    |    5 +
 drivers/infiniband/ulp/srpt/ib_srpt.c                  |    1 
 drivers/isdn/mISDN/stack.c                             |    6 +-
 drivers/macintosh/mediabay.c                           |    2 
 drivers/macintosh/therm_pm72.c                         |    2 
 drivers/macintosh/therm_windtunnel.c                   |    2 
 drivers/md/md.c                                        |    4 -
 drivers/media/dvb-core/dvb_ca_en50221.c                |    1 
 drivers/media/pci/ttpci/av7110.c                       |    2 
 drivers/media/rc/ir-raw.c                              |    1 
 drivers/media/rc/lirc_dev.c                            |    3 +
 drivers/media/usb/gspca/m5602/m5602_s5k83a.c           |    2 
 drivers/media/usb/pvrusb2/pvrusb2-context.c            |    5 +
 drivers/media/usb/pvrusb2/pvrusb2-dvb.c                |    5 +
 drivers/memstick/host/r592.c                           |    2 
 drivers/mfd/ucb1x00-ts.c                               |    2 
 drivers/misc/genwqe/card_base.c                        |    2 
 drivers/misc/genwqe/card_ddcb.c                        |    1 
 drivers/misc/kgdbts.c                                  |    5 +
 drivers/misc/sgi-xp/xpc_main.c                         |   10 ++-
 drivers/mmc/card/queue.c                               |    1 
 drivers/mmc/core/sdio_irq.c                            |    1 
 drivers/net/irda/stir4200.c                            |    2 
 drivers/net/wimax/i2400m/usb-rx.c                      |    6 +-
 drivers/net/wimax/i2400m/usb-tx.c                      |    6 +-
 drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c     |    1 
 drivers/net/wireless/libertas/main.c                   |    1 
 drivers/net/xen-netback/netback.c                      |    5 +
 drivers/parisc/power.c                                 |    1 
 drivers/pci/hotplug/cpci_hotplug_core.c                |    2 
 drivers/pci/hotplug/cpqphp_ctrl.c                      |    1 
 drivers/pci/hotplug/ibmphp_hpc.c                       |    1 
 drivers/platform/x86/intel_ips.c                       |    3 +
 drivers/s390/cio/crw.c                                 |    5 +
 drivers/s390/crypto/ap_bus.c                           |    1 
 drivers/s390/scsi/zfcp_erp.c                           |    5 +
 drivers/sbus/char/bbc_envctrl.c                        |    1 
 drivers/sbus/char/envctrl.c                            |    1 
 drivers/scsi/aacraid/commsup.c                         |    2 
 drivers/scsi/bnx2fc/bnx2fc_fcoe.c                      |    1 
 drivers/scsi/bnx2i/bnx2i_hwi.c                         |    2 
 drivers/scsi/fcoe/fcoe.c                               |    1 
 drivers/scsi/ibmvscsi/ibmvfc.c                         |    5 +
 drivers/scsi/ibmvscsi/ibmvscsi.c                       |    5 +
 drivers/scsi/libsas/sas_scsi_host.c                    |    1 
 drivers/scsi/lpfc/lpfc_hbadisc.c                       |    5 +
 drivers/scsi/mvumi.c                                   |    1 
 drivers/scsi/qla2xxx/qla_os.c                          |    1 
 drivers/staging/ft1000/ft1000-usb/ft1000_usb.c         |    1 
 drivers/staging/gdm72xx/gdm_usb.c                      |    1 
 drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c |    3 +
 drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c |    8 ++
 drivers/staging/lustre/lnet/lnet/router.c              |    1 
 drivers/staging/lustre/lnet/selftest/timer.c           |    1 
 drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c        |    5 +
 drivers/staging/lustre/lustre/ldlm/ldlm_pool.c         |    5 +
 drivers/staging/lustre/lustre/libcfs/tracefile.c       |    1 
 drivers/staging/lustre/lustre/libcfs/workitem.c        |    5 +
 drivers/staging/lustre/lustre/llite/llite_capa.c       |    5 +
 drivers/staging/lustre/lustre/llite/llite_close.c      |    5 +
 drivers/staging/lustre/lustre/llite/lloop.c            |    3 -
 drivers/staging/lustre/lustre/llite/statahead.c        |   10 ++-
 drivers/staging/lustre/lustre/mgc/mgc_request.c        |    6 +-
 drivers/staging/lustre/lustre/obdclass/genops.c        |    4 -
 drivers/staging/lustre/lustre/ptlrpc/import.c          |    5 +
 drivers/staging/lustre/lustre/ptlrpc/pinger.c          |   10 ++-
 drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c         |    5 +
 drivers/staging/lustre/lustre/ptlrpc/sec_gc.c          |    5 +
 drivers/staging/lustre/lustre/ptlrpc/service.c         |    8 +-
 drivers/staging/media/lirc/lirc_zilog.c                |    2 
 drivers/staging/rtl8188eu/core/rtw_cmd.c               |    1 
 drivers/staging/rtl8712/rtl8712_cmd.c                  |    1 
 drivers/staging/speakup/thread.c                       |    1 
 drivers/staging/usbip/stub_rx.c                        |    1 
 drivers/staging/usbip/stub_tx.c                        |    5 +
 drivers/staging/usbip/usbip_event.c                    |    5 +
 drivers/staging/usbip/vhci_rx.c                        |    1 
 drivers/staging/usbip/vhci_tx.c                        |    5 +
 drivers/target/iscsi/iscsi_target.c                    |    7 +-
 drivers/target/iscsi/iscsi_target_login.c              |    1 
 drivers/tty/bfin_jtag_comm.c                           |    1 
 drivers/tty/hvc/hvcs.c                                 |    1 
 drivers/tty/metag_da.c                                 |    5 +
 drivers/tty/serial/mrst_max3110.c                      |    6 +-
 drivers/usb/early/ehci-dbgp.c                          |    1 
 drivers/uwb/uwbd.c                                     |    5 +
 drivers/vhost/vhost.c                                  |    1 
 drivers/xen/xenbus/xenbus_xs.c                         |    5 +
 fs/dlm/lockspace.c                                     |    1 
 fs/dlm/recoverd.c                                      |    1 
 fs/ext4/mmp.c                                          |    1 
 fs/jbd/journal.c                                       |    1 
 fs/jffs2/background.c                                  |    1 
 fs/jfs/jfs_logmgr.c                                    |    1 
 fs/jfs/jfs_txnmgr.c                                    |    2 
 fs/nilfs2/segment.c                                    |    1 
 fs/ocfs2/cluster/heartbeat.c                           |    1 
 fs/ocfs2/dlm/dlmrecovery.c                             |   10 ++-
 fs/ocfs2/dlm/dlmthread.c                               |    5 +
 fs/ocfs2/dlmglue.c                                     |    5 +
 fs/ocfs2/journal.c                                     |    5 +
 kernel/power/swap.c                                    |   15 +++--
 kernel/rcutorture.c                                    |   48 +++++++++++++----
 kernel/trace/ring_buffer.c                             |    2 
 kernel/trace/ring_buffer_benchmark.c                   |    2 
 kernel/trace/trace_events.c                            |    4 +
 kernel/trace/trace_selftest.c                          |    1 
 mm/kmemleak.c                                          |    2 
 net/bluetooth/bnep/core.c                              |    1 
 net/bluetooth/cmtp/core.c                              |    1 
 net/bluetooth/hidp/core.c                              |    1 
 net/core/pktgen.c                                      |    1 
 net/netfilter/ipvs/ip_vs_sync.c                        |   11 ++-
 samples/trace_events/trace-events-sample.c             |    1 
 sound/pci/emu10k1/emu10k1_main.c                       |    1 
 141 files changed, 340 insertions(+), 130 deletions(-)

--- a/arch/arm/mach-rpc/ecard.c
+++ b/arch/arm/mach-rpc/ecard.c
@@ -274,7 +274,8 @@ ecard_task(void * unused)
 	while (1) {
 		struct ecard_request *req;
 
-		wait_event_interruptible(ecard_wait, ecard_req != NULL);
+		wait_event_interruptible(ecard_wait, ({ kgr_task_safe(current);
+					ecard_req != NULL; }));
 
 		req = xchg(&ecard_req, NULL);
 		if (req != NULL) {
--- a/arch/powerpc/kernel/eeh_event.c
+++ b/arch/powerpc/kernel/eeh_event.c
@@ -55,6 +55,8 @@ static int eeh_event_handler(void * dumm
 	struct eeh_pe *pe;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		if (down_interruptible(&eeh_eventlist_sem))
 			break;
 
--- a/arch/powerpc/platforms/44x/warp.c
+++ b/arch/powerpc/platforms/44x/warp.c
@@ -267,6 +267,7 @@ static int pika_dtm_thread(void __iomem
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
+		kgr_task_safe(current);
 	}
 
 	return 0;
--- a/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c
+++ b/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c
@@ -66,6 +66,7 @@ static int shutdown_thread_fn(void *data
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
+		kgr_task_safe(current);
 	}
 
 	return 0;
--- a/arch/powerpc/platforms/83xx/suspend.c
+++ b/arch/powerpc/platforms/83xx/suspend.c
@@ -265,7 +265,8 @@ static int mpc83xx_suspend_begin(suspend
 static int agent_thread_fn(void *data)
 {
 	while (1) {
-		wait_event_interruptible(agent_wq, pci_pm_state >= 2);
+		wait_event_interruptible(agent_wq, ({ kgr_task_safe(current);
+				pci_pm_state >= 2; }));
 		try_to_freeze();
 
 		if (signal_pending(current) || pci_pm_state < 2)
--- a/arch/powerpc/platforms/cell/spufs/sched.c
+++ b/arch/powerpc/platforms/cell/spufs/sched.c
@@ -1012,6 +1012,7 @@ static int spusched_thread(void *unused)
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		kgr_task_safe(current);
 		for (node = 0; node < MAX_NUMNODES; node++) {
 			struct mutex *mtx = &cbe_spu_info[node].list_mutex;
 
--- a/arch/powerpc/platforms/ps3/device-init.c
+++ b/arch/powerpc/platforms/ps3/device-init.c
@@ -752,8 +752,9 @@ static int ps3_notification_read_write(s
 	}
 	pr_debug("%s:%u: notification %s issued\n", __func__, __LINE__, op);
 
-	res = wait_event_interruptible(dev->done.wait,
-				       dev->done.done || kthread_should_stop());
+	res = wait_event_interruptible(dev->done.wait, ({
+				kgr_task_safe(current);
+				dev->done.done || kthread_should_stop(); }));
 	if (kthread_should_stop())
 		res = -EINTR;
 	if (res) {
--- a/arch/powerpc/platforms/pseries/cmm.c
+++ b/arch/powerpc/platforms/pseries/cmm.c
@@ -308,6 +308,7 @@ static int cmm_thread(void *dummy)
 
 	while (1) {
 		timeleft = msleep_interruptible(delay * 1000);
+		kgr_task_safe(current);
 
 		if (kthread_should_stop() || timeleft)
 			break;
--- a/arch/s390/mm/cmm.c
+++ b/arch/s390/mm/cmm.c
@@ -148,10 +148,11 @@ static int cmm_thread(void *dummy)
 	int rc;
 
 	while (1) {
-		rc = wait_event_interruptible(cmm_thread_wait,
+		rc = wait_event_interruptible(cmm_thread_wait, ({
+			kgr_task_safe(current);
 			(!cmm_suspended && (cmm_pages != cmm_pages_target ||
 			 cmm_timed_pages != cmm_timed_pages_target)) ||
-			 kthread_should_stop());
+			 kthread_should_stop(); }));
 		if (kthread_should_stop() || rc == -ERESTARTSYS) {
 			cmm_pages_target = cmm_pages;
 			cmm_timed_pages_target = cmm_timed_pages;
--- a/arch/sparc/kernel/ds.c
+++ b/arch/sparc/kernel/ds.c
@@ -1032,6 +1032,7 @@ static int ds_thread(void *__unused)
 		if (list_empty(&ds_work_list))
 			schedule();
 		finish_wait(&ds_wait, &wait);
+		kgr_task_safe(current);
 
 		if (kthread_should_stop())
 			break;
--- a/arch/x86/kernel/apm_32.c
+++ b/arch/x86/kernel/apm_32.c
@@ -1451,6 +1451,7 @@ static void apm_mainloop(void)
 	set_current_state(TASK_INTERRUPTIBLE);
 	for (;;) {
 		schedule_timeout(APM_CHECK_TIMEOUT);
+		kgr_task_safe(current);
 		if (kthread_should_stop())
 			break;
 		/*
--- a/arch/x86/mm/pageattr-test.c
+++ b/arch/x86/mm/pageattr-test.c
@@ -236,6 +236,7 @@ static int do_pageattr_test(void *__unus
 {
 	while (!kthread_should_stop()) {
 		schedule_timeout_interruptible(HZ*30);
+		kgr_task_safe(current);
 		if (pageattr_test() < 0)
 			break;
 		if (print)
--- a/drivers/block/aoe/aoecmd.c
+++ b/drivers/block/aoe/aoecmd.c
@@ -1329,6 +1329,7 @@ kthread(void *vp)
 	set_user_nice(current, -10);
 	complete(&k->rendez);	/* tell spawner we're running */
 	do {
+		kgr_task_safe(current);
 		spin_lock_irq(k->lock);
 		more = k->fn(k->id);
 		if (!more) {
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -3735,6 +3735,8 @@ static int scan_thread(void *data)
 		if (kthread_should_stop())
 			break;
 
+		kgr_task_safe(current);
+
 		while (1) {
 			mutex_lock(&scan_mutex);
 			if (list_empty(&scan_q)) {
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -551,9 +551,10 @@ static int loop_thread(void *data)
 
 	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
 
-		wait_event_interruptible(lo->lo_event,
+		wait_event_interruptible(lo->lo_event, ({
+				kgr_task_safe(current);
 				!bio_list_empty(&lo->lo_bio_list) ||
-				kthread_should_stop());
+				kthread_should_stop(); }));
 
 		if (bio_list_empty(&lo->lo_bio_list))
 			continue;
--- a/drivers/block/mtip32xx/mtip32xx.c
+++ b/drivers/block/mtip32xx/mtip32xx.c
@@ -3235,8 +3235,10 @@ static int mtip_service_thread(void *dat
 		 * the condition is to check neither an internal command is
 		 * is in progress nor error handling is active
 		 */
-		wait_event_interruptible(port->svc_wait, (port->flags) &&
-			!(port->flags & MTIP_PF_PAUSE_IO));
+		wait_event_interruptible(port->svc_wait, ({
+			kgr_task_safe(current);
+			(port->flags) &&
+			!(port->flags & MTIP_PF_PAUSE_IO); }));
 
 		if (kthread_should_stop())
 			goto st_out;
--- a/drivers/block/nbd.c
+++ b/drivers/block/nbd.c
@@ -536,9 +536,10 @@ static int nbd_thread(void *data)
 	set_user_nice(current, -20);
 	while (!kthread_should_stop() || !list_empty(&nbd->waiting_queue)) {
 		/* wait for something to do */
-		wait_event_interruptible(nbd->waiting_wq,
+		wait_event_interruptible(nbd->waiting_wq, ({
+					 kgr_task_safe(current);
 					 kthread_should_stop() ||
-					 !list_empty(&nbd->waiting_queue));
+					 !list_empty(&nbd->waiting_queue); }));
 
 		/* extract request */
 		if (list_empty(&nbd->waiting_queue))
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -1918,6 +1918,7 @@ static int nvme_kthread(void *data)
 	struct nvme_dev *dev, *next;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_lock(&dev_list_lock);
 		list_for_each_entry_safe(dev, next, &dev_list, node) {
--- a/drivers/bluetooth/btmrvl_main.c
+++ b/drivers/bluetooth/btmrvl_main.c
@@ -495,6 +495,7 @@ static int btmrvl_service_main_thread(vo
 	init_waitqueue_entry(&wait, current);
 
 	for (;;) {
+		kgr_task_safe(current);
 		add_wait_queue(&thread->wait_q, &wait);
 
 		set_current_state(TASK_INTERRUPTIBLE);
--- a/drivers/char/apm-emulation.c
+++ b/drivers/char/apm-emulation.c
@@ -488,8 +488,8 @@ static int kapmd(void *arg)
 	do {
 		apm_event_t event;
 
-		wait_event_interruptible(kapmd_wait,
-				!queue_empty(&kapmd_queue) || kthread_should_stop());
+		wait_event_interruptible(kapmd_wait, ({ kgr_task_safe(current);
+				!queue_empty(&kapmd_queue) || kthread_should_stop(); }));
 
 		if (kthread_should_stop())
 			break;
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -332,6 +332,7 @@ static int hwrng_fillfn(void *unused)
 	long rc;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		if (!current_rng)
 			break;
 		rc = rng_get_data(current_rng, rng_fillbuf,
--- a/drivers/crypto/mv_cesa.c
+++ b/drivers/crypto/mv_cesa.c
@@ -637,6 +637,8 @@ static int queue_manag(void *data)
 
 		schedule();
 
+		kgr_task_safe(current);
+
 	} while (!kthread_should_stop());
 	return 0;
 }
--- a/drivers/dma/dmatest.c
+++ b/drivers/dma/dmatest.c
@@ -612,6 +612,8 @@ static int dmatest_func(void *data)
 
 		total_tests++;
 
+		kgr_task_safe(current);
+
 		/* honor alignment restrictions */
 		if (thread->type == DMA_MEMCPY)
 			align = dev->copy_align;
--- a/drivers/hv/hv_balloon.c
+++ b/drivers/hv/hv_balloon.c
@@ -1257,6 +1257,8 @@ static int dm_thread_func(void *dm_dev)
 	struct hv_dynmem_device *dm = dm_dev;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		wait_for_completion_interruptible_timeout(
 						&dm_device.config_event, 1*HZ);
 		/*
--- a/drivers/hwmon/adt7470.c
+++ b/drivers/hwmon/adt7470.c
@@ -300,6 +300,8 @@ static int adt7470_update_thread(void *p
 	struct adt7470_data *data = i2c_get_clientdata(client);
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		mutex_lock(&data->lock);
 		adt7470_read_temperatures(client, data);
 		mutex_unlock(&data->lock);
--- a/drivers/infiniband/core/fmr_pool.c
+++ b/drivers/infiniband/core/fmr_pool.c
@@ -179,6 +179,8 @@ static int ib_fmr_cleanup_thread(void *p
 	struct ib_fmr_pool *pool = pool_ptr;
 
 	do {
+		kgr_task_safe(current);
+
 		if (atomic_read(&pool->flush_ser) - atomic_read(&pool->req_ser) < 0) {
 			ib_fmr_batch_release(pool);
 
--- a/drivers/infiniband/hw/nes/nes_mgt.c
+++ b/drivers/infiniband/hw/nes/nes_mgt.c
@@ -582,8 +582,9 @@ static int mgt_thread(void *context)
 	struct nes_rskb_cb *cb;
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(nesvnic->mgt_wait_queue,
-					 skb_queue_len(&nesvnic->mgt_skb_list) || kthread_should_stop());
+		wait_event_interruptible(nesvnic->mgt_wait_queue, ({
+					 kgr_task_safe(current);
+					 skb_queue_len(&nesvnic->mgt_skb_list) || kthread_should_stop(); }));
 		while ((skb_queue_len(&nesvnic->mgt_skb_list)) && !kthread_should_stop()) {
 			skb = skb_dequeue(&nesvnic->mgt_skb_list);
 			cb = (struct nes_rskb_cb *)&skb->cb[0];
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@ -2066,6 +2066,7 @@ static int srpt_compl_thread(void *arg)
 	while (!kthread_should_stop()) {
 		wait_event_interruptible(ch->wait_queue,
 			(srpt_process_completion(ch->cq, ch),
+			 kgr_task_safe(current),
 			 kthread_should_stop()));
 	}
 	printk(KERN_INFO "Session %s: kernel thread %s (PID %d) stopped\n",
--- a/drivers/isdn/mISDN/stack.c
+++ b/drivers/isdn/mISDN/stack.c
@@ -285,8 +285,10 @@ mISDNStackd(void *data)
 		st->sleep_cnt++;
 #endif
 		test_and_clear_bit(mISDN_STACK_ACTIVE, &st->status);
-		wait_event_interruptible(st->workq, (st->status &
-						     mISDN_STACK_ACTION_MASK));
+		wait_event_interruptible(st->workq, ({
+					kgr_task_safe(current);
+					(st->status &
+						     mISDN_STACK_ACTION_MASK); }));
 		if (*debug & DEBUG_MSG_THREAD)
 			printk(KERN_DEBUG "%s: %s wake status %08lx\n",
 			       __func__, dev_name(&st->dev->dev), st->status);
--- a/drivers/macintosh/mediabay.c
+++ b/drivers/macintosh/mediabay.c
@@ -544,6 +544,8 @@ static int media_bay_task(void *x)
 	int	i;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		for (i = 0; i < media_bay_count; ++i) {
 			mutex_lock(&media_bays[i].lock);
 			if (!media_bays[i].sleeping)
--- a/drivers/macintosh/therm_pm72.c
+++ b/drivers/macintosh/therm_pm72.c
@@ -1870,6 +1870,8 @@ static int main_control_loop(void *x)
 		elapsed = jiffies - start;
 		if (elapsed < HZ)
 			schedule_timeout_interruptible(HZ - elapsed);
+
+		kgr_task_safe(current);
 	}
 
  out:
--- a/drivers/macintosh/therm_windtunnel.c
+++ b/drivers/macintosh/therm_windtunnel.c
@@ -279,6 +279,8 @@ static int control_loop(void *dummy)
 	mutex_unlock(&x.lock);
 
 	for (;;) {
+		kgr_task_safe(current);
+
 		msleep_interruptible(8000);
 		if (kthread_should_stop())
 			break;
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -6920,9 +6920,9 @@ static int md_thread(void * arg)
 			flush_signals(current);
 
 		wait_event_interruptible_timeout
-			(thread->wqueue,
+			(thread->wqueue, ({ kgr_task_safe(current);
 			 test_bit(THREAD_WAKEUP, &thread->flags)
-			 || kthread_should_stop(),
+			 || kthread_should_stop(); }),
 			 thread->timeout);
 
 		clear_bit(THREAD_WAKEUP, &thread->flags);
--- a/drivers/media/dvb-core/dvb_ca_en50221.c
+++ b/drivers/media/dvb-core/dvb_ca_en50221.c
@@ -995,6 +995,7 @@ static int dvb_ca_en50221_thread(void *d
 				return 0;
 		}
 		ca->wakeup = 0;
+		kgr_task_safe(current);
 
 		/* go through all the slots processing them */
 		for (slot = 0; slot < ca->slot_count; slot++) {
--- a/drivers/media/pci/ttpci/av7110.c
+++ b/drivers/media/pci/ttpci/av7110.c
@@ -265,6 +265,8 @@ static int arm_thread(void *data)
 			break;
 		}
 
+		kgr_task_safe(current);
+
 		if (!av7110->arm_ready)
 			continue;
 
--- a/drivers/media/rc/ir-raw.c
+++ b/drivers/media/rc/ir-raw.c
@@ -39,6 +39,7 @@ static int ir_raw_event_thread(void *dat
 	int retval;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 
 		spin_lock_irq(&raw->lock);
 		retval = kfifo_len(&raw->kfifo);
--- a/drivers/media/rc/lirc_dev.c
+++ b/drivers/media/rc/lirc_dev.c
@@ -131,6 +131,8 @@ static int lirc_thread(void *irctl)
 		ir->d.name, ir->d.minor);
 
 	do {
+		kgr_task_safe(current);
+
 		if (ir->open) {
 			if (ir->jiffies_to_wait) {
 				set_current_state(TASK_INTERRUPTIBLE);
@@ -144,6 +146,7 @@ static int lirc_thread(void *irctl)
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule();
 		}
+
 	} while (!kthread_should_stop());
 
 	dev_dbg(ir->d.dev, LOGHEAD "poll thread ended\n",
--- a/drivers/media/usb/gspca/m5602/m5602_s5k83a.c
+++ b/drivers/media/usb/gspca/m5602/m5602_s5k83a.c
@@ -178,6 +178,8 @@ static int rotation_thread_function(void
 
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!schedule_timeout(msecs_to_jiffies(100))) {
+		kgr_task_safe(current);
+
 		if (mutex_lock_interruptible(&sd->gspca_dev.usb_lock))
 			break;
 
--- a/drivers/media/usb/pvrusb2/pvrusb2-context.c
+++ b/drivers/media/usb/pvrusb2/pvrusb2-context.c
@@ -171,9 +171,10 @@ static int pvr2_context_thread_func(void
 			pvr2_context_check(mp);
 		}
 		wait_event_interruptible(
-			pvr2_context_sync_data,
+			pvr2_context_sync_data, ({
+			kgr_task_safe(current);
 			((pvr2_context_notify_first != NULL) ||
-			 pvr2_context_shutok()));
+			 pvr2_context_shutok()); }));
 	} while (!pvr2_context_shutok());
 
 	pvr2_context_cleaned_flag = !0;
--- a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c
+++ b/drivers/media/usb/pvrusb2/pvrusb2-dvb.c
@@ -76,9 +76,10 @@ static int pvr2_dvb_feed_func(struct pvr
 		/* Wait until more buffers become available or we're
 		   told not to wait any longer. */
 		ret = wait_event_interruptible(
-		    adap->buffer_wait_data,
+		    adap->buffer_wait_data, ({
+		    kgr_task_safe(current);
 		    (pvr2_stream_get_ready_count(stream) > 0) ||
-		    kthread_should_stop());
+		    kthread_should_stop(); }));
 		if (ret < 0) break;
 	}
 
--- a/drivers/memstick/host/r592.c
+++ b/drivers/memstick/host/r592.c
@@ -569,6 +569,8 @@ static int r592_process_thread(void *dat
 	unsigned long flags;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		spin_lock_irqsave(&dev->io_thread_lock, flags);
 		set_current_state(TASK_INTERRUPTIBLE);
 		error = memstick_next_req(dev->host, &dev->req);
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -220,6 +220,8 @@ static int ucb1x00_thread(void *_ts)
 		if (frozen)
 			ignore = true;
 
+		kgr_task_safe(current);
+
 		ucb1x00_adc_enable(ts->ucb);
 
 		x = ucb1x00_ts_read_xpos(ts);
--- a/drivers/misc/genwqe/card_base.c
+++ b/drivers/misc/genwqe/card_base.c
@@ -788,6 +788,8 @@ static int genwqe_health_thread(void *da
 
  health_thread_begin:
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		rc = wait_event_interruptible_timeout(cd->health_waitq,
 			 (genwqe_health_check_cond(cd, &gfir) ||
 			  (should_stop = kthread_should_stop())),
--- a/drivers/misc/genwqe/card_ddcb.c
+++ b/drivers/misc/genwqe/card_ddcb.c
@@ -1155,6 +1155,7 @@ static int genwqe_card_thread(void *data
 	struct genwqe_dev *cd = (struct genwqe_dev *)data;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 
 		genwqe_check_ddcb_queue(cd, &cd->queue);
 
--- a/drivers/misc/kgdbts.c
+++ b/drivers/misc/kgdbts.c
@@ -191,8 +191,11 @@ static int kgdbts_unreg_thread(void *ptr
 	/* Wait until the tests are complete and then ungresiter the I/O
 	 * driver.
 	 */
-	while (!final_ack)
+	while (!final_ack) {
+		kgr_task_safe(current);
+
 		msleep_interruptible(1500);
+	}
 	/* Pause for any other threads to exit after final ack. */
 	msleep_interruptible(1000);
 	if (configured)
--- a/drivers/misc/sgi-xp/xpc_main.c
+++ b/drivers/misc/sgi-xp/xpc_main.c
@@ -298,11 +298,12 @@ xpc_hb_checker(void *ignore)
 		}
 
 		/* wait for IRQ or timeout */
-		(void)wait_event_interruptible(xpc_activate_IRQ_wq,
+		(void)wait_event_interruptible(xpc_activate_IRQ_wq, ({
+					       kgr_task_safe(current);
 					       (time_is_before_eq_jiffies(
 						xpc_hb_check_timeout) ||
 						xpc_activate_IRQ_rcvd > 0 ||
-						xpc_exiting));
+						xpc_exiting); }));
 	}
 
 	xpc_stop_hb_beater();
@@ -675,9 +676,10 @@ xpc_kthread_waitmsgs(struct xpc_partitio
 		dev_dbg(xpc_chan, "idle kthread calling "
 			"wait_event_interruptible_exclusive()\n");
 
-		(void)wait_event_interruptible_exclusive(ch->idle_wq,
+		(void)wait_event_interruptible_exclusive(ch->idle_wq, ({
+				kgr_task_safe(current);
 				(n_of_deliverable_payloads(ch) > 0 ||
-				 (ch->flags & XPC_C_DISCONNECTING)));
+				 (ch->flags & XPC_C_DISCONNECTING)); }));
 
 		atomic_dec(&ch->kthreads_idle);
 
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -95,6 +95,7 @@ static int mmc_queue_thread(void *d)
 			}
 			up(&mq->thread_sem);
 			schedule();
+			kgr_task_safe(current);
 			down(&mq->thread_sem);
 		}
 	} while (1);
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -156,6 +156,7 @@ static int sdio_irq_thread(void *_host)
 		}
 		if (!kthread_should_stop())
 			schedule_timeout(period);
+		kgr_task_safe(current);
 		set_current_state(TASK_RUNNING);
 	} while (!kthread_should_stop());
 
--- a/drivers/net/irda/stir4200.c
+++ b/drivers/net/irda/stir4200.c
@@ -796,7 +796,7 @@ static int stir_transmit_thread(void *ar
 		/* sleep if nothing to send */
                 set_current_state(TASK_INTERRUPTIBLE);
                 schedule();
-
+		kgr_task_safe(current);
 	}
         return 0;
 }
--- a/drivers/net/wimax/i2400m/usb-rx.c
+++ b/drivers/net/wimax/i2400m/usb-rx.c
@@ -349,10 +349,10 @@ int i2400mu_rxd(void *_i2400mu)
 		d_printf(2, dev, "RX: waiting for messages\n");
 		pending = 0;
 		wait_event_interruptible(
-			i2400mu->rx_wq,
+			i2400mu->rx_wq, ({ kgr_task_safe(current);
 			(kthread_should_stop()	/* check this first! */
-			 || (pending = atomic_read(&i2400mu->rx_pending_count)))
-			);
+			 || (pending = atomic_read(&i2400mu->rx_pending_count)));
+			}));
 		if (kthread_should_stop())
 			break;
 		if (pending == 0)
--- a/drivers/net/wimax/i2400m/usb-tx.c
+++ b/drivers/net/wimax/i2400m/usb-tx.c
@@ -195,10 +195,10 @@ int i2400mu_txd(void *_i2400mu)
 		d_printf(2, dev, "TX: waiting for messages\n");
 		tx_msg = NULL;
 		wait_event_interruptible(
-			i2400mu->tx_wq,
+			i2400mu->tx_wq, ({ kgr_task_safe(current);
 			(kthread_should_stop()	/* check this first! */
-			 || (tx_msg = i2400m_tx_msg_get(i2400m, &tx_msg_size)))
-			);
+			 || (tx_msg = i2400m_tx_msg_get(i2400m, &tx_msg_size)));
+			}));
 		if (kthread_should_stop())
 			break;
 		WARN_ON(tx_msg == NULL);	/* should not happen...*/
--- a/drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/net/wireless/brcm80211/brcmfmac/dhd_sdio.c
@@ -3748,6 +3748,7 @@ brcmf_sdbrcm_watchdog_thread(void *data)
 	allow_signal(SIGTERM);
 	/* Run until signal received */
 	while (1) {
+		kgr_task_safe(current);
 		if (kthread_should_stop())
 			break;
 		if (!wait_for_completion_interruptible(&bus->watchdog_wait)) {
--- a/drivers/net/wireless/libertas/main.c
+++ b/drivers/net/wireless/libertas/main.c
@@ -466,6 +466,7 @@ static int lbs_thread(void *data)
 		lbs_deb_thread("1: currenttxskb %p, dnld_sent %d\n",
 				priv->currenttxskb, priv->dnld_sent);
 
+		kgr_task_safe(current);
 		add_wait_queue(&priv->waitq, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_lock_irq(&priv->driver_lock);
--- a/drivers/net/xen-netback/netback.c
+++ b/drivers/net/xen-netback/netback.c
@@ -1641,10 +1641,11 @@ int xenvif_kthread(void *data)
 	struct xenvif *vif = data;
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(vif->wq,
+		wait_event_interruptible(vif->wq, ({
+					 kgr_task_safe(current);
 					 rx_work_todo(vif) ||
 					 vif->disabled ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 
 		/* This frontend is found to be rogue, disable it in
 		 * kthread context. Currently this is only set when
--- a/drivers/parisc/power.c
+++ b/drivers/parisc/power.c
@@ -120,6 +120,7 @@ static int kpowerswd(void *param)
 		int button_not_pressed;
 		unsigned long soft_power_reg = (unsigned long) param;
 
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(pwrsw_enabled ? HZ : HZ/POWERSWITCH_POLL_PER_SEC);
 		__set_current_state(TASK_RUNNING);
 
--- a/drivers/pci/hotplug/cpci_hotplug_core.c
+++ b/drivers/pci/hotplug/cpci_hotplug_core.c
@@ -511,6 +511,7 @@ event_thread(void *data)
 		dbg("event thread sleeping");
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		kgr_task_safe(current);
 		if (kthread_should_stop())
 			break;
 		do {
@@ -542,6 +543,7 @@ poll_thread(void *data)
 	int rc;
 
 	while (1) {
+		kgr_task_safe(current);
 		if (kthread_should_stop() || signal_pending(current))
 			break;
 		if (controller->ops->query_enum()) {
--- a/drivers/pci/hotplug/cpqphp_ctrl.c
+++ b/drivers/pci/hotplug/cpqphp_ctrl.c
@@ -1749,6 +1749,7 @@ static int event_thread(void* data)
 		dbg("!!!!event_thread sleeping\n");
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		kgr_task_safe(current);
 
 		if (kthread_should_stop())
 			break;
--- a/drivers/pci/hotplug/ibmphp_hpc.c
+++ b/drivers/pci/hotplug/ibmphp_hpc.c
@@ -831,6 +831,7 @@ static int poll_hpc(void *data)
 	debug ("%s - Entry\n", __func__);
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		/* try to get the lock to do some kind of hardware access */
 		down (&semOperations);
 
--- a/drivers/platform/x86/intel_ips.c
+++ b/drivers/platform/x86/intel_ips.c
@@ -812,6 +812,7 @@ static int ips_adjust(void *data)
 			ips_gpu_lower(ips);
 
 sleep:
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(msecs_to_jiffies(IPS_ADJUST_PERIOD));
 	} while (!kthread_should_stop());
 
@@ -1018,6 +1019,7 @@ static int ips_monitor(void *data)
 			mchp_samples[i] = mchp;
 		}
 
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));
 		if (kthread_should_stop())
 			break;
@@ -1107,6 +1109,7 @@ static int ips_monitor(void *data)
 
 		__set_current_state(TASK_INTERRUPTIBLE);
 		mod_timer(&timer, expire);
+		kgr_task_safe(current);
 		schedule();
 
 		/* Calculate actual sample period for power averaging */
--- a/drivers/s390/cio/crw.c
+++ b/drivers/s390/cio/crw.c
@@ -65,8 +65,9 @@ static int crw_collect_info(void *unused
 	unsigned int chain;
 
 repeat:
-	signal = wait_event_interruptible(crw_handler_wait_q,
-					  atomic_read(&crw_nr_req) > 0);
+	signal = wait_event_interruptible(crw_handler_wait_q, ({
+					  kgr_task_safe(current);
+					  atomic_read(&crw_nr_req) > 0; }));
 	if (unlikely(signal))
 		atomic_inc(&crw_nr_req);
 	chain = 0;
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@ -1931,6 +1931,7 @@ static int ap_poll_thread(void *data)
 			schedule();
 			continue;
 		}
+		kgr_task_safe(current);
 		add_wait_queue(&ap_poll_wait, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (kthread_should_stop())
--- a/drivers/s390/scsi/zfcp_erp.c
+++ b/drivers/s390/scsi/zfcp_erp.c
@@ -1342,9 +1342,10 @@ static int zfcp_erp_thread(void *data)
 	unsigned long flags;
 
 	for (;;) {
-		wait_event_interruptible(adapter->erp_ready_wq,
+		wait_event_interruptible(adapter->erp_ready_wq, ({
+			   kgr_task_safe(current);
 			   !list_empty(&adapter->erp_ready_head) ||
-			   kthread_should_stop());
+			   kthread_should_stop(); }));
 
 		if (kthread_should_stop())
 			break;
--- a/drivers/sbus/char/bbc_envctrl.c
+++ b/drivers/sbus/char/bbc_envctrl.c
@@ -425,6 +425,7 @@ static int kenvctrld(void *__unused)
 		struct bbc_cpu_temperature *tp;
 		struct bbc_fan_control *fp;
 
+		kgr_task_safe(current);
 		msleep_interruptible(POLL_INTERVAL);
 		if (kthread_should_stop())
 			break;
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -1004,6 +1004,7 @@ static int kenvctrld(void *__unused)
 
 	printk(KERN_INFO PFX "%s starting...\n", current->comm);
 	for (;;) {
+		kgr_task_safe(current);
 		msleep_interruptible(poll_interval);
 
 		if (kthread_should_stop())
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -1652,6 +1652,8 @@ int aac_command_thread(void *data)
 	set_current_state(TASK_INTERRUPTIBLE);
 	dprintk ((KERN_INFO "aac_command_thread start\n"));
 	while (1) {
+		kgr_task_safe(current);
+
 		spin_lock_irqsave(dev->queues->queue[HostNormCmdQueue].lock, flags);
 		while(!list_empty(&(dev->queues->queue[HostNormCmdQueue].cmdq))) {
 			struct list_head *entry;
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -614,6 +614,7 @@ int bnx2fc_percpu_io_thread(void *arg)
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!kthread_should_stop()) {
 		schedule();
+		kgr_task_safe(current);
 		spin_lock_bh(&p->fp_work_lock);
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
--- a/drivers/scsi/bnx2i/bnx2i_hwi.c
+++ b/drivers/scsi/bnx2i/bnx2i_hwi.c
@@ -1873,6 +1873,8 @@ int bnx2i_percpu_io_thread(void *arg)
 	set_user_nice(current, -20);
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
+
 		spin_lock_bh(&p->p_work_lock);
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -1885,6 +1885,7 @@ retry:
 			spin_unlock_bh(&p->fcoe_rx_list.lock);
 			schedule();
 			set_current_state(TASK_RUNNING);
+			kgr_task_safe(current);
 			goto retry;
 		}
 
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@ -4525,8 +4525,9 @@ static int ibmvfc_work(void *data)
 	set_user_nice(current, -20);
 
 	while (1) {
-		rc = wait_event_interruptible(vhost->work_wait_q,
-					      ibmvfc_work_to_do(vhost));
+		rc = wait_event_interruptible(vhost->work_wait_q, ({
+					      kgr_task_safe(current);
+					      ibmvfc_work_to_do(vhost); }));
 
 		BUG_ON(rc);
 
--- a/drivers/scsi/ibmvscsi/ibmvscsi.c
+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
@@ -2232,8 +2232,9 @@ static int ibmvscsi_work(void *data)
 	set_user_nice(current, -20);
 
 	while (1) {
-		rc = wait_event_interruptible(hostdata->work_wait_q,
-					      ibmvscsi_work_to_do(hostdata));
+		rc = wait_event_interruptible(hostdata->work_wait_q, ({
+					      kgr_task_safe(current);
+					      ibmvscsi_work_to_do(hostdata); }));
 
 		BUG_ON(rc);
 
--- a/drivers/scsi/libsas/sas_scsi_host.c
+++ b/drivers/scsi/libsas/sas_scsi_host.c
@@ -1072,6 +1072,7 @@ static int sas_queue_thread(void *_sas_h
 	struct sas_ha_struct *sas_ha = _sas_ha;
 
 	while (1) {
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
 		sas_queue(sas_ha);
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -737,10 +737,11 @@ lpfc_do_work(void *p)
 
 	while (!kthread_should_stop()) {
 		/* wait and check worker queue activities */
-		rc = wait_event_interruptible(phba->work_waitq,
+		rc = wait_event_interruptible(phba->work_waitq, ({
+					kgr_task_safe(current);
 					(test_and_clear_bit(LPFC_DATA_READY,
 							    &phba->data_flags)
-					 || kthread_should_stop()));
+					 || kthread_should_stop()); }));
 		/* Signal wakeup shall terminate the worker thread */
 		if (rc) {
 			lpfc_printf_log(phba, KERN_ERR, LOG_ELS,
--- a/drivers/scsi/mvumi.c
+++ b/drivers/scsi/mvumi.c
@@ -1649,6 +1649,7 @@ static int mvumi_rescan_bus(void *data)
 	struct mvumi_device *mv_dev = NULL , *dev_next;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (!atomic_read(&mhba->pnp_count))
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -4861,6 +4861,7 @@ qla2x00_do_dpc(void *data)
 
 		schedule();
 		__set_current_state(TASK_RUNNING);
+		kgr_task_safe(current);
 
 		if (!base_vha->flags.init_done || ha->flags.mbox_busy)
 			goto end_loop;
--- a/drivers/staging/ft1000/ft1000-usb/ft1000_usb.c
+++ b/drivers/staging/ft1000/ft1000-usb/ft1000_usb.c
@@ -42,6 +42,7 @@ static int ft1000_poll_thread(void *arg)
 	int ret;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		msleep(10);
 		if (!gPollingfailed) {
 			ret = ft1000_poll(arg);
--- a/drivers/staging/gdm72xx/gdm_usb.c
+++ b/drivers/staging/gdm72xx/gdm_usb.c
@@ -740,6 +740,7 @@ static int k_mode_thread(void *arg)
 	int ret;
 
 	while (!k_mode_stop) {
+		kgr_task_safe(current);
 
 		spin_lock_irqsave(&k_lock, flags2);
 		while (!list_empty(&k_list)) {
--- a/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c
+++ b/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c
@@ -3205,6 +3205,7 @@ kiblnd_connd (void *arg)
 			continue;
 
 		/* Nothing to do for 'timeout'  */
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&kiblnd_data.kib_connd_waitq, &wait);
 		spin_unlock_irqrestore(&kiblnd_data.kib_connd_lock, flags);
@@ -3420,6 +3421,7 @@ kiblnd_scheduler(void *arg)
 		if (did_something)
 			continue;
 
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue_exclusive(&sched->ibs_waitq, &wait);
 		spin_unlock_irqrestore(&sched->ibs_lock, flags);
@@ -3497,6 +3499,7 @@ kiblnd_failover_thread(void *arg)
 		/* long sleep if no more pending failover */
 		long_sleep = list_empty(&kiblnd_data.kib_failed_devs);
 
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&kiblnd_data.kib_failover_waitq, &wait);
 		write_unlock_irqrestore(glock, flags);
--- a/drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c
+++ b/drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c
@@ -1535,8 +1535,10 @@ int ksocknal_scheduler(void *arg)
 
 			if (!did_something) {   /* wait for something to do */
 				cfs_wait_event_interruptible_exclusive(
-					sched->kss_waitq,
-					!ksocknal_sched_cansleep(sched), rc);
+					sched->kss_waitq, ({
+					kgr_task_safe(current);
+					!ksocknal_sched_cansleep(sched); }),
+					rc);
 				LASSERT (rc == 0);
 			} else {
 				cond_resched();
@@ -2223,6 +2225,7 @@ ksocknal_connd (void *arg)
 		}
 
 		/* Nothing to do for 'timeout'  */
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue_exclusive(&ksocknal_data.ksnd_connd_waitq, &wait);
 		spin_unlock_bh(connd_lock);
@@ -2641,6 +2644,7 @@ ksocknal_reaper (void *arg)
 			waitq_timedwait (&wait, TASK_INTERRUPTIBLE,
 					     timeout);
 
+		kgr_task_safe(current);
 		set_current_state (TASK_RUNNING);
 		remove_wait_queue (&ksocknal_data.ksnd_reaper_waitq, &wait);
 
--- a/drivers/staging/lustre/lnet/lnet/router.c
+++ b/drivers/staging/lustre/lnet/lnet/router.c
@@ -1170,6 +1170,7 @@ lnet_router_checker(void *arg)
 		int	cpt;
 		int	cpt2;
 
+		kgr_task_safe(current);
 		cpt = lnet_net_lock_current();
 rescan:
 		version = the_lnet.ln_routers_version;
--- a/drivers/staging/lustre/lnet/selftest/timer.c
+++ b/drivers/staging/lustre/lnet/selftest/timer.c
@@ -179,6 +179,7 @@ stt_timer_main (void *arg)
 	cfs_block_allsigs();
 
 	while (!stt_data.stt_shuttingdown) {
+		kgr_task_safe(current);
 		stt_check_timers(&stt_data.stt_prev_slot);
 
 		rc = wait_event_timeout(stt_data.stt_waitq,
--- a/drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c
+++ b/drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c
@@ -845,8 +845,9 @@ static int ldlm_bl_thread_main(void *arg
 
 		if (blwi == NULL) {
 			atomic_dec(&blp->blp_busy_threads);
-			l_wait_event_exclusive(blp->blp_waitq,
-					 (blwi = ldlm_bl_get_work(blp)) != NULL,
+			l_wait_event_exclusive(blp->blp_waitq, ({
+					 kgr_task_safe(current);
+					 (blwi = ldlm_bl_get_work(blp)) != NULL; }),
 					 &lwi);
 			busy = atomic_inc_return(&blp->blp_busy_threads);
 		} else {
--- a/drivers/staging/lustre/lustre/ldlm/ldlm_pool.c
+++ b/drivers/staging/lustre/lustre/ldlm/ldlm_pool.c
@@ -1324,9 +1324,10 @@ static int ldlm_pools_thread_main(void *
 		 */
 		lwi = LWI_TIMEOUT(cfs_time_seconds(min(s_time, c_time)),
 				  NULL, NULL);
-		l_wait_event(thread->t_ctl_waitq,
+		l_wait_event(thread->t_ctl_waitq, ({
+			     kgr_task_safe(current);
 			     thread_is_stopping(thread) ||
-			     thread_is_event(thread),
+			     thread_is_event(thread); }),
 			     &lwi);
 
 		if (thread_test_and_clear_flags(thread, SVC_STOPPING))
--- a/drivers/staging/lustre/lustre/libcfs/tracefile.c
+++ b/drivers/staging/lustre/lustre/libcfs/tracefile.c
@@ -1068,6 +1068,7 @@ end_loop:
 				break;
 			}
 		}
+		kgr_task_safe(current);
 		init_waitqueue_entry_current(&__wait);
 		add_wait_queue(&tctl->tctl_waitq, &__wait);
 		set_current_state(TASK_INTERRUPTIBLE);
--- a/drivers/staging/lustre/lustre/libcfs/workitem.c
+++ b/drivers/staging/lustre/lustre/libcfs/workitem.c
@@ -288,8 +288,9 @@ cfs_wi_scheduler (void *arg)
 		}
 
 		cfs_wi_sched_unlock(sched);
-		cfs_wait_event_interruptible_exclusive(sched->ws_waitq,
-				!cfs_wi_sched_cansleep(sched), rc);
+		cfs_wait_event_interruptible_exclusive(sched->ws_waitq, ({
+				kgr_task_safe(current);
+				!cfs_wi_sched_cansleep(sched); }), rc);
 		cfs_wi_sched_lock(sched);
 	}
 
--- a/drivers/staging/lustre/lustre/llite/llite_capa.c
+++ b/drivers/staging/lustre/lustre/llite/llite_capa.c
@@ -175,9 +175,10 @@ static int capa_thread_main(void *unused
 	wake_up(&ll_capa_thread.t_ctl_waitq);
 
 	while (1) {
-		l_wait_event(ll_capa_thread.t_ctl_waitq,
+		l_wait_event(ll_capa_thread.t_ctl_waitq, ({
+			     kgr_task_safe(current);
 			     !thread_is_running(&ll_capa_thread) ||
-			     have_expired_capa(),
+			     have_expired_capa(); }),
 			     &lwi);
 
 		if (!thread_is_running(&ll_capa_thread))
--- a/drivers/staging/lustre/lustre/llite/llite_close.c
+++ b/drivers/staging/lustre/lustre/llite/llite_close.c
@@ -341,8 +341,9 @@ static int ll_close_thread(void *arg)
 		struct ll_inode_info *lli;
 		struct inode *inode;
 
-		l_wait_event_exclusive(lcq->lcq_waitq,
-				       (lli = ll_close_next_lli(lcq)) != NULL,
+		l_wait_event_exclusive(lcq->lcq_waitq, ({
+				       kgr_task_safe(current);
+				       (lli = ll_close_next_lli(lcq)) != NULL; }),
 				       &lwi);
 		if (IS_ERR(lli))
 			break;
--- a/drivers/staging/lustre/lustre/llite/lloop.c
+++ b/drivers/staging/lustre/lustre/llite/lloop.c
@@ -426,7 +426,8 @@ static int loop_thread(void *data)
 	up(&lo->lo_sem);
 
 	for (;;) {
-		wait_event(lo->lo_bh_wait, loop_active(lo));
+		wait_event(lo->lo_bh_wait, ({ kgr_task_safe(current);
+					loop_active(lo); }));
 		if (!atomic_read(&lo->lo_pending)) {
 			int exiting = 0;
 			spin_lock_irq(&lo->lo_lock);
--- a/drivers/staging/lustre/lustre/llite/statahead.c
+++ b/drivers/staging/lustre/lustre/llite/statahead.c
@@ -972,9 +972,10 @@ static int ll_agl_thread(void *arg)
 	wake_up(&thread->t_ctl_waitq);
 
 	while (1) {
-		l_wait_event(thread->t_ctl_waitq,
+		l_wait_event(thread->t_ctl_waitq, ({
+			     kgr_task_safe(current);
 			     !agl_list_empty(sai) ||
-			     !thread_is_running(thread),
+			     !thread_is_running(thread); }),
 			     &lwi);
 
 		if (!thread_is_running(thread))
@@ -1187,10 +1188,11 @@ do_it:
 			 */
 			ll_release_page(page, 0);
 			while (1) {
-				l_wait_event(thread->t_ctl_waitq,
+				l_wait_event(thread->t_ctl_waitq, ({
+					     kgr_task_safe(current);
 					     !sa_received_empty(sai) ||
 					     sai->sai_sent == sai->sai_replied||
-					     !thread_is_running(thread),
+					     !thread_is_running(thread); }),
 					     &lwi);
 
 				while (!sa_received_empty(sai))
--- a/drivers/staging/lustre/lustre/mgc/mgc_request.c
+++ b/drivers/staging/lustre/lustre/mgc/mgc_request.c
@@ -484,7 +484,8 @@ static int mgc_requeue_thread(void *data
 		to = MGC_TIMEOUT_MIN_SECONDS * HZ;
 		to += rand * HZ / 100; /* rand is centi-seconds */
 		lwi = LWI_TIMEOUT(to, NULL, NULL);
-		l_wait_event(rq_waitq, rq_state & RQ_STOP, &lwi);
+		l_wait_event(rq_waitq, ({ kgr_task_safe(current);
+					rq_state & RQ_STOP; }), &lwi);
 
 		/*
 		 * iterate & processing through the list. for each cld, process
@@ -531,7 +532,8 @@ static int mgc_requeue_thread(void *data
 
 		/* Wait a bit to see if anyone else needs a requeue */
 		lwi = (struct l_wait_info) { 0 };
-		l_wait_event(rq_waitq, rq_state & (RQ_NOW | RQ_STOP),
+		l_wait_event(rq_waitq, ({ kgr_task_safe(current);
+					rq_state & (RQ_NOW | RQ_STOP); }),
 			     &lwi);
 		spin_lock(&config_list_lock);
 	}
--- a/drivers/staging/lustre/lustre/obdclass/genops.c
+++ b/drivers/staging/lustre/lustre/obdclass/genops.c
@@ -1711,8 +1711,8 @@ static int obd_zombie_impexp_thread(void
 	while (!test_bit(OBD_ZOMBIE_STOP, &obd_zombie_flags)) {
 		struct l_wait_info lwi = { 0 };
 
-		l_wait_event(obd_zombie_waitq,
-			     !obd_zombie_impexp_check(NULL), &lwi);
+		l_wait_event(obd_zombie_waitq, ({ kgr_task_safe(current);
+			     !obd_zombie_impexp_check(NULL); }), &lwi);
 		obd_zombie_impexp_cull();
 
 		/*
--- a/drivers/staging/lustre/lustre/ptlrpc/import.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/import.c
@@ -307,8 +307,9 @@ void ptlrpc_invalidate_import(struct obd
 			cfs_timeout_cap(cfs_time_seconds(timeout)),
 			(timeout > 1)?cfs_time_seconds(1):cfs_time_seconds(1)/2,
 			NULL, NULL);
-		rc = l_wait_event(imp->imp_recovery_waitq,
-				  (atomic_read(&imp->imp_inflight) == 0),
+		rc = l_wait_event(imp->imp_recovery_waitq, ({
+				  kgr_task_safe(current);
+				  (atomic_read(&imp->imp_inflight) == 0); }),
 				  &lwi);
 		if (rc) {
 			const char *cli_tgt = obd2cli_tgt(imp->imp_obd);
--- a/drivers/staging/lustre/lustre/ptlrpc/pinger.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/pinger.c
@@ -345,9 +345,10 @@ static int ptlrpc_pinger_main(void *arg)
 						time_to_next_wake,
 						cfs_time_seconds(1)),
 					  NULL, NULL);
-			l_wait_event(thread->t_ctl_waitq,
+			l_wait_event(thread->t_ctl_waitq, ({
+				     kgr_task_safe(current);
 				     thread_is_stopping(thread) ||
-				     thread_is_event(thread),
+				     thread_is_event(thread); }),
 				     &lwi);
 			if (thread_test_and_clear_flags(thread, SVC_STOPPING)) {
 				break;
@@ -650,8 +651,9 @@ static int ping_evictor_main(void *arg)
 	CDEBUG(D_HA, "Starting Ping Evictor\n");
 	pet_state = PET_READY;
 	while (1) {
-		l_wait_event(pet_waitq, (!list_empty(&pet_list)) ||
-			     (pet_state == PET_TERMINATE), &lwi);
+		l_wait_event(pet_waitq, ({ kgr_task_safe(current);
+			     (!list_empty(&pet_list)) ||
+			     (pet_state == PET_TERMINATE); }), &lwi);
 
 		/* loop until all obd's will be removed */
 		if ((pet_state == PET_TERMINATE) && list_empty(&pet_list))
--- a/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c
@@ -425,8 +425,9 @@ static int ptlrpcd(void *arg)
 				  ptlrpc_expired_set, set);
 
 		lu_context_enter(&env.le_ctx);
-		l_wait_event(set->set_waitq,
-			     ptlrpcd_check(&env, pc), &lwi);
+		l_wait_event(set->set_waitq, ({
+			     kgr_task_safe(current);
+			     ptlrpcd_check(&env, pc); }), &lwi);
 		lu_context_exit(&env.le_ctx);
 
 		/*
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c
@@ -200,9 +200,10 @@ again:
 		sec_process_ctx_list();
 
 		lwi = LWI_TIMEOUT(SEC_GC_INTERVAL * HZ, NULL, NULL);
-		l_wait_event(thread->t_ctl_waitq,
+		l_wait_event(thread->t_ctl_waitq, ({
+			     kgr_task_safe(current);
 			     thread_is_stopping(thread) ||
-			     thread_is_signal(thread),
+			     thread_is_signal(thread); }),
 			     &lwi);
 
 		if (thread_test_and_clear_flags(thread, SVC_STOPPING))
--- a/drivers/staging/lustre/lustre/ptlrpc/service.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/service.c
@@ -2236,12 +2236,13 @@ ptlrpc_wait_event(struct ptlrpc_service_
 
 	cond_resched();
 
-	l_wait_event_exclusive_head(svcpt->scp_waitq,
+	l_wait_event_exclusive_head(svcpt->scp_waitq, ({
+				kgr_task_safe(current);
 				ptlrpc_thread_stopping(thread) ||
 				ptlrpc_server_request_incoming(svcpt) ||
 				ptlrpc_server_request_pending(svcpt, false) ||
 				ptlrpc_rqbd_pending(svcpt) ||
-				ptlrpc_at_check(svcpt), &lwi);
+				ptlrpc_at_check(svcpt); }), &lwi);
 
 	if (ptlrpc_thread_stopping(thread))
 		return -EINTR;
@@ -2487,7 +2488,8 @@ static int ptlrpc_hr_main(void *arg)
 	wake_up(&ptlrpc_hr.hr_waitq);
 
 	while (!ptlrpc_hr.hr_stopping) {
-		l_wait_condition(hrt->hrt_waitq, hrt_dont_sleep(hrt, &replies));
+		l_wait_condition(hrt->hrt_waitq, ({ kgr_task_safe(current);
+					hrt_dont_sleep(hrt, &replies); }));
 
 		while (!list_empty(&replies)) {
 			struct ptlrpc_reply_state *rs;
--- a/drivers/staging/media/lirc/lirc_zilog.c
+++ b/drivers/staging/media/lirc/lirc_zilog.c
@@ -357,6 +357,7 @@ static int add_to_buf(struct IR *ir)
 	 * data and we have space
 	 */
 	do {
+		kgr_task_safe(current);
 		if (kthread_should_stop()) {
 			ret = -ENODATA;
 			break;
@@ -476,6 +477,7 @@ static int lirc_thread(void *arg)
 	dprintk("poll thread started\n");
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		/* if device not opened, we can sleep half a second */
--- a/drivers/staging/rtl8188eu/core/rtw_cmd.c
+++ b/drivers/staging/rtl8188eu/core/rtw_cmd.c
@@ -335,6 +335,7 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("start r871x rtw_cmd_thread !!!!\n"));
 
 	while (1) {
+		kgr_task_safe(current);
 		if (_rtw_down_sema(&pcmdpriv->cmd_queue_sema) == _FAIL)
 			break;
 
--- a/drivers/staging/rtl8712/rtl8712_cmd.c
+++ b/drivers/staging/rtl8712/rtl8712_cmd.c
@@ -330,6 +330,7 @@ int r8712_cmd_thread(void *context)
 
 	thread_enter(padapter);
 	while (1) {
+		kgr_task_safe(current);
 		if ((_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
 			break;
 		if ((padapter->bDriverStopped == true) ||
--- a/drivers/staging/speakup/thread.c
+++ b/drivers/staging/speakup/thread.c
@@ -22,6 +22,7 @@ int speakup_thread(void *data)
 	while (1) {
 		DEFINE_WAIT(wait);
 		while (1) {
+			kgr_task_safe(current);
 			spin_lock_irqsave(&speakup_info.spinlock, flags);
 			our_sound = spk_unprocessed_sound;
 			spk_unprocessed_sound.active = 0;
--- a/drivers/staging/usbip/stub_rx.c
+++ b/drivers/staging/usbip/stub_rx.c
@@ -593,6 +593,7 @@ int stub_rx_loop(void *data)
 	struct usbip_device *ud = data;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		if (usbip_event_happened(ud))
 			break;
 
--- a/drivers/staging/usbip/stub_tx.c
+++ b/drivers/staging/usbip/stub_tx.c
@@ -387,10 +387,11 @@ int stub_tx_loop(void *data)
 		if (stub_send_ret_unlink(sdev) < 0)
 			break;
 
-		wait_event_interruptible(sdev->tx_waitq,
+		wait_event_interruptible(sdev->tx_waitq, ({
+					 kgr_task_safe(current);
 					 (!list_empty(&sdev->priv_tx) ||
 					  !list_empty(&sdev->unlink_tx) ||
-					  kthread_should_stop()));
+					  kthread_should_stop()); }));
 	}
 
 	return 0;
--- a/drivers/staging/usbip/usbip_event.c
+++ b/drivers/staging/usbip/usbip_event.c
@@ -66,9 +66,10 @@ static int event_handler_loop(void *data
 	struct usbip_device *ud = data;
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(ud->eh_waitq,
+		wait_event_interruptible(ud->eh_waitq, ({
+					 kgr_task_safe(current);
 					 usbip_event_happened(ud) ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 		usbip_dbg_eh("wakeup\n");
 
 		if (event_handler(ud) < 0)
--- a/drivers/staging/usbip/vhci_rx.c
+++ b/drivers/staging/usbip/vhci_rx.c
@@ -260,6 +260,7 @@ int vhci_rx_loop(void *data)
 	struct usbip_device *ud = data;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		if (usbip_event_happened(ud))
 			break;
 
--- a/drivers/staging/usbip/vhci_tx.c
+++ b/drivers/staging/usbip/vhci_tx.c
@@ -212,10 +212,11 @@ int vhci_tx_loop(void *data)
 		if (vhci_send_cmd_unlink(vdev) < 0)
 			break;
 
-		wait_event_interruptible(vdev->waitq_tx,
+		wait_event_interruptible(vdev->waitq_tx, ({
+					 kgr_task_safe(current);
 					 (!list_empty(&vdev->priv_tx) ||
 					  !list_empty(&vdev->unlink_tx) ||
-					  kthread_should_stop()));
+					  kthread_should_stop()); }));
 
 		usbip_dbg_vhci_tx("pending urbs ?, now wake up\n");
 	}
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -3945,8 +3945,10 @@ int iscsi_target_tx_thread(void *arg)
 		 */
 		iscsit_thread_check_cpumask(conn, current, 1);
 
-		wait_event_interruptible(conn->queues_wq,
-					 !iscsit_conn_all_queues_empty(conn));
+		wait_event_interruptible(conn->queues_wq, ({
+					 kgr_task_safe(current);
+					 !iscsit_conn_all_queues_empty(conn);
+					 }));
 
 		if (signal_pending(current))
 			goto transport_err;
@@ -4088,6 +4090,7 @@ int iscsi_target_rx_thread(void *arg)
 	}
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		/*
 		 * Ensure that both TX and RX per connection kthreads
 		 * are scheduled to run on the same CPU.
--- a/drivers/target/iscsi/iscsi_target_login.c
+++ b/drivers/target/iscsi/iscsi_target_login.c
@@ -1467,6 +1467,7 @@ int iscsi_target_login_thread(void *arg)
 	allow_signal(SIGINT);
 
 	while (1) {
+		kgr_task_safe(current);
 		ret = __iscsi_target_login_thread(np);
 		/*
 		 * We break and exit here unless another sock_accept() call
--- a/drivers/tty/bfin_jtag_comm.c
+++ b/drivers/tty/bfin_jtag_comm.c
@@ -72,6 +72,7 @@ bfin_jc_emudat_manager(void *arg)
 
 	while (!kthread_should_stop()) {
 		struct tty_struct *tty = tty_port_tty_get(&port);
+		kgr_task_safe(current);
 		/* no one left to give data to, so sleep */
 		if (tty == NULL && circ_empty(&bfin_jc_write_buf)) {
 			pr_debug("waiting for readers\n");
--- a/drivers/tty/hvc/hvcs.c
+++ b/drivers/tty/hvc/hvcs.c
@@ -647,6 +647,7 @@ static int khvcsd(void *unused)
 	__set_current_state(TASK_RUNNING);
 
 	do {
+		kgr_task_safe(current);
 		hvcs_todo_mask = 0;
 		hvcs_kicked = 0;
 		wmb();
--- a/drivers/tty/metag_da.c
+++ b/drivers/tty/metag_da.c
@@ -289,8 +289,9 @@ static int put_data(void *arg)
 		if (stall)
 			msleep(25);
 
-		wait_event_interruptible(dashtty_waitqueue,
-					 atomic_read(&dashtty_xmit_cnt));
+		wait_event_interruptible(dashtty_waitqueue, ({
+					 kgr_task_safe(current);
+					 atomic_read(&dashtty_xmit_cnt); }));
 	}
 
 	return 0;
--- a/drivers/tty/serial/mrst_max3110.c
+++ b/drivers/tty/serial/mrst_max3110.c
@@ -410,8 +410,9 @@ static int max3110_main_thread(void *_ma
 	pr_info(PR_FMT "start main thread\n");
 
 	do {
-		wait_event_interruptible(*wq,
-				max->uart_flags || kthread_should_stop());
+		wait_event_interruptible(*wq, ({
+				kgr_task_safe(current);
+				max->uart_flags || kthread_should_stop(); }));
 
 		mutex_lock(&max->thread_mutex);
 
@@ -453,6 +454,7 @@ static int max3110_read_thread(void *_ma
 
 	pr_info(PR_FMT "start read thread\n");
 	do {
+		kgr_task_safe(current);
 		/*
 		 * If can't acquire the mutex, it means the main thread
 		 * is running which will also perform the rx job
--- a/drivers/usb/early/ehci-dbgp.c
+++ b/drivers/usb/early/ehci-dbgp.c
@@ -1074,6 +1074,7 @@ static int kgdbdbgp_reader_thread(void *
 	int ret;
 
 	while (readl(&ehci_debug->control) & DBGP_ENABLED) {
+		kgr_task_safe(current);
 		kgdbdbgp_loop_cnt = 1;
 		ret = kgdbdbgp_read_char();
 		kgdbdbgp_loop_cnt = DBGP_LOOPS;
--- a/drivers/uwb/uwbd.c
+++ b/drivers/uwb/uwbd.c
@@ -273,9 +273,10 @@ static int uwbd(void *param)
 
 	while (1) {
 		wait_event_interruptible_timeout(
-			rc->uwbd.wq,
+			rc->uwbd.wq, ({
+			kgr_task_safe(current);
 			!list_empty(&rc->uwbd.event_list)
-			  || (should_stop = kthread_should_stop()),
+			  || (should_stop = kthread_should_stop()); }),
 			HZ);
 		if (should_stop)
 			break;
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -211,6 +211,7 @@ static int vhost_worker(void *data)
 	use_mm(dev->mm);
 
 	for (;;) {
+		kgr_task_safe(current);
 		/* mb paired w/ kthread_stop */
 		set_current_state(TASK_INTERRUPTIBLE);
 
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -771,8 +771,9 @@ static int xenwatch_thread(void *unused)
 	struct xs_stored_msg *msg;
 
 	for (;;) {
-		wait_event_interruptible(watch_events_waitq,
-					 !list_empty(&watch_events));
+		wait_event_interruptible(watch_events_waitq, ({
+					 kgr_task_safe(current);
+					 !list_empty(&watch_events); }));
 
 		if (kthread_should_stop())
 			break;
--- a/fs/dlm/lockspace.c
+++ b/fs/dlm/lockspace.c
@@ -265,6 +265,7 @@ static int dlm_scand(void *data)
 	struct dlm_ls *ls;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		ls = find_ls_to_scan();
 		if (ls) {
 			if (dlm_lock_recovery_try(ls)) {
--- a/fs/dlm/recoverd.c
+++ b/fs/dlm/recoverd.c
@@ -288,6 +288,7 @@ static int dlm_recoverd(void *arg)
 	wake_up(&ls->ls_recover_lock_wait);
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (!test_bit(LSFL_RECOVER_WORK, &ls->ls_flags) &&
 		    !test_bit(LSFL_RECOVER_DOWN, &ls->ls_flags))
--- a/fs/ext4/mmp.c
+++ b/fs/ext4/mmp.c
@@ -153,6 +153,7 @@ static int kmmpd(void *data)
 	       sizeof(mmp->mmp_nodename));
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		if (++seq > EXT4_MMP_SEQ_MAX)
 			seq = 1;
 
--- a/fs/jbd/journal.c
+++ b/fs/jbd/journal.c
@@ -212,6 +212,7 @@ loop:
 			spin_lock(&journal->j_state_lock);
 		}
 		finish_wait(&journal->j_wait_commit, &wait);
+		kgr_task_safe(current);
 	}
 
 	jbd_debug(1, "kjournald wakes\n");
--- a/fs/jffs2/background.c
+++ b/fs/jffs2/background.c
@@ -87,6 +87,7 @@ static int jffs2_garbage_collect_thread(
 
 	set_freezable();
 	for (;;) {
+		kgr_task_safe(current);
 		allow_signal(SIGHUP);
 	again:
 		spin_lock(&c->erase_completion_lock);
--- a/fs/jfs/jfs_logmgr.c
+++ b/fs/jfs/jfs_logmgr.c
@@ -2343,6 +2343,7 @@ int jfsIOWait(void *arg)
 	struct lbuf *bp;
 
 	do {
+		kgr_task_safe(current);
 		spin_lock_irq(&log_redrive_lock);
 		while ((bp = log_redrive_list)) {
 			log_redrive_list = bp->l_redrive_next;
--- a/fs/jfs/jfs_txnmgr.c
+++ b/fs/jfs/jfs_txnmgr.c
@@ -2753,6 +2753,7 @@ int jfs_lazycommit(void *arg)
 	struct jfs_sb_info *sbi;
 
 	do {
+		kgr_task_safe(current);
 		LAZY_LOCK(flags);
 		jfs_commit_thread_waking = 0;	/* OK to wake another thread */
 		while (!list_empty(&TxAnchor.unlock_queue)) {
@@ -2937,6 +2938,7 @@ int jfs_sync(void *arg)
 	tid_t tid;
 
 	do {
+		kgr_task_safe(current);
 		/*
 		 * write each inode on the anonymous inode list
 		 */
--- a/fs/nilfs2/segment.c
+++ b/fs/nilfs2/segment.c
@@ -2487,6 +2487,7 @@ static int nilfs_segctor_thread(void *ar
 
 	spin_lock(&sci->sc_state_lock);
  loop:
+	kgr_task_safe(current);
 	for (;;) {
 		int mode;
 
--- a/fs/ocfs2/cluster/heartbeat.c
+++ b/fs/ocfs2/cluster/heartbeat.c
@@ -1136,6 +1136,7 @@ static int o2hb_thread(void *data)
 
 	while (!kthread_should_stop() &&
 	       !reg->hr_unclean_stop && !reg->hr_aborted_start) {
+		kgr_task_safe(current);
 		/* We track the time spent inside
 		 * o2hb_do_disk_heartbeat so that we avoid more than
 		 * hr_timeout_ms between disk writes. On busy systems
--- a/fs/ocfs2/dlm/dlmrecovery.c
+++ b/fs/ocfs2/dlm/dlmrecovery.c
@@ -317,8 +317,9 @@ static int dlm_recovery_thread(void *dat
 				mlog_errno(status);
 		}
 
-		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,
-						 kthread_should_stop(),
+		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq, ({
+						 kgr_task_safe(current);
+						 kthread_should_stop(); }),
 						 timeout);
 	}
 
@@ -732,8 +733,9 @@ static int dlm_remaster_locks(struct dlm
 		}
 		/* wait to be signalled, with periodic timeout
 		 * to check for node death */
-		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,
-					 kthread_should_stop(),
+		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq, ({
+					 kgr_task_safe(current);
+					 kthread_should_stop(); }),
 					 msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));
 
 	}
--- a/fs/ocfs2/dlm/dlmthread.c
+++ b/fs/ocfs2/dlm/dlmthread.c
@@ -742,9 +742,10 @@ in_progress:
 			continue;
 		}
 
-		wait_event_interruptible_timeout(dlm->dlm_thread_wq,
+		wait_event_interruptible_timeout(dlm->dlm_thread_wq, ({
+						 kgr_task_safe(current);
 						 !dlm_dirty_list_empty(dlm) ||
-						 kthread_should_stop(),
+						 kthread_should_stop(); }),
 						 timeout);
 	}
 
--- a/fs/ocfs2/dlmglue.c
+++ b/fs/ocfs2/dlmglue.c
@@ -4068,9 +4068,10 @@ static int ocfs2_downconvert_thread(void
 	while (!(kthread_should_stop() &&
 		ocfs2_downconvert_thread_lists_empty(osb))) {
 
-		wait_event_interruptible(osb->dc_event,
+		wait_event_interruptible(osb->dc_event, ({
+					 kgr_task_safe(current);
 					 ocfs2_downconvert_thread_should_wake(osb) ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 
 		mlog(0, "downconvert_thread: awoken\n");
 
--- a/fs/ocfs2/journal.c
+++ b/fs/ocfs2/journal.c
@@ -2180,9 +2180,10 @@ static int ocfs2_commit_thread(void *arg
 	while (!(kthread_should_stop() &&
 		 atomic_read(&journal->j_num_trans) == 0)) {
 
-		wait_event_interruptible(osb->checkpoint_event,
+		wait_event_interruptible(osb->checkpoint_event, ({
+					 kgr_task_safe(current);
 					 atomic_read(&journal->j_num_trans)
-					 || kthread_should_stop());
+					 || kthread_should_stop(); }));
 
 		status = ocfs2_commit_cache(osb);
 		if (status < 0)
--- a/kernel/power/swap.c
+++ b/kernel/power/swap.c
@@ -502,8 +502,9 @@ static int crc32_threadfn(void *data)
 	unsigned i;
 
 	while (1) {
-		wait_event(d->go, atomic_read(&d->ready) ||
-		                  kthread_should_stop());
+		wait_event(d->go, ({ kgr_task_safe(current);
+				  atomic_read(&d->ready) ||
+		                  kthread_should_stop(); }));
 		if (kthread_should_stop()) {
 			d->thr = NULL;
 			atomic_set(&d->stop, 1);
@@ -545,8 +546,9 @@ static int lzo_compress_threadfn(void *d
 	struct cmp_data *d = data;
 
 	while (1) {
-		wait_event(d->go, atomic_read(&d->ready) ||
-		                  kthread_should_stop());
+		wait_event(d->go, ({ kgr_task_safe(current);
+				  atomic_read(&d->ready) ||
+		                  kthread_should_stop(); }));
 		if (kthread_should_stop()) {
 			d->thr = NULL;
 			d->ret = -1;
@@ -1033,8 +1035,9 @@ static int lzo_decompress_threadfn(void
 	struct dec_data *d = data;
 
 	while (1) {
-		wait_event(d->go, atomic_read(&d->ready) ||
-		                  kthread_should_stop());
+		wait_event(d->go, ({ kgr_task_safe(current);
+				  atomic_read(&d->ready) ||
+		                  kthread_should_stop(); }));
 		if (kthread_should_stop()) {
 			d->thr = NULL;
 			d->ret = -1;
--- a/kernel/rcutorture.c
+++ b/kernel/rcutorture.c
@@ -687,6 +687,7 @@ static int rcu_torture_boost(void *arg)
 	init_rcu_head_on_stack(&rbi.rcu);
 	/* Each pass through the following loop does one boost-test cycle. */
 	do {
+		kgr_task_safe(current);
 		/* Wait for the next test interval. */
 		oldstarttime = boost_starttime;
 		while (ULONG_CMP_LT(jiffies, oldstarttime)) {
@@ -746,8 +747,10 @@ checkwait:	rcu_stutter_wait("rcu_torture
 	/* Clean up and exit. */
 	VERBOSE_PRINTK_STRING("rcu_torture_boost task stopping");
 	rcutorture_shutdown_absorb("rcu_torture_boost");
-	while (!kthread_should_stop() || rbi.inflight)
+	while (!kthread_should_stop() || rbi.inflight) {
+		kgr_task_safe(current);
 		schedule_timeout_uninterruptible(1);
+	}
 	smp_mb(); /* order accesses to ->inflight before stack-frame death. */
 	destroy_rcu_head_on_stack(&rbi.rcu);
 	return 0;
@@ -766,6 +769,7 @@ rcu_torture_fqs(void *arg)
 
 	VERBOSE_PRINTK_STRING("rcu_torture_fqs task started");
 	do {
+		kgr_task_safe(current);
 		fqs_resume_time = jiffies + fqs_stutter * HZ;
 		while (ULONG_CMP_LT(jiffies, fqs_resume_time) &&
 		       !kthread_should_stop()) {
@@ -806,6 +810,7 @@ rcu_torture_writer(void *arg)
 	set_user_nice(current, 19);
 
 	do {
+		kgr_task_safe(current);
 		schedule_timeout_uninterruptible(1);
 		rp = rcu_torture_alloc();
 		if (rp == NULL)
@@ -854,8 +859,10 @@ rcu_torture_writer(void *arg)
 	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
 	VERBOSE_PRINTK_STRING("rcu_torture_writer task stopping");
 	rcutorture_shutdown_absorb("rcu_torture_writer");
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		schedule_timeout_uninterruptible(1);
+	}
 	return 0;
 }
 
@@ -872,6 +879,7 @@ rcu_torture_fakewriter(void *arg)
 	set_user_nice(current, 19);
 
 	do {
+		kgr_task_safe(current);
 		schedule_timeout_uninterruptible(1 + rcu_random(&rand)%10);
 		udelay(rcu_random(&rand) & 0x3ff);
 		if (cur_ops->cb_barrier != NULL &&
@@ -892,8 +900,10 @@ rcu_torture_fakewriter(void *arg)
 
 	VERBOSE_PRINTK_STRING("rcu_torture_fakewriter task stopping");
 	rcutorture_shutdown_absorb("rcu_torture_fakewriter");
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		schedule_timeout_uninterruptible(1);
+	}
 	return 0;
 }
 
@@ -990,6 +1000,7 @@ rcu_torture_reader(void *arg)
 		setup_timer_on_stack(&t, rcu_torture_timer, 0);
 
 	do {
+		kgr_task_safe(current);
 		if (irqreader && cur_ops->irq_capable) {
 			if (!timer_pending(&t))
 				mod_timer(&t, jiffies + 1);
@@ -1038,8 +1049,10 @@ rcu_torture_reader(void *arg)
 	rcutorture_shutdown_absorb("rcu_torture_reader");
 	if (irqreader && cur_ops->irq_capable)
 		del_timer_sync(&t);
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		schedule_timeout_uninterruptible(1);
+	}
 	return 0;
 }
 
@@ -1152,6 +1165,7 @@ rcu_torture_stats(void *arg)
 {
 	VERBOSE_PRINTK_STRING("rcu_torture_stats task started");
 	do {
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(stat_interval * HZ);
 		rcu_torture_stats_print();
 		rcutorture_shutdown_absorb("rcu_torture_stats");
@@ -1236,6 +1250,7 @@ rcu_torture_shuffle(void *arg)
 {
 	VERBOSE_PRINTK_STRING("rcu_torture_shuffle task started");
 	do {
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(shuffle_interval * HZ);
 		rcu_torture_shuffle_tasks();
 		rcutorture_shutdown_absorb("rcu_torture_shuffle");
@@ -1252,6 +1267,7 @@ rcu_torture_stutter(void *arg)
 {
 	VERBOSE_PRINTK_STRING("rcu_torture_stutter task started");
 	do {
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(stutter * HZ);
 		stutter_pause_test = 1;
 		if (!kthread_should_stop())
@@ -1348,6 +1364,7 @@ rcu_torture_shutdown(void *arg)
 	jiffies_snap = ACCESS_ONCE(jiffies);
 	while (ULONG_CMP_LT(jiffies_snap, shutdown_time) &&
 	       !kthread_should_stop()) {
+		kgr_task_safe(current);
 		delta = shutdown_time - jiffies_snap;
 		if (verbose)
 			pr_alert("%s" TORTURE_FLAG
@@ -1396,6 +1413,7 @@ rcu_torture_onoff(void *arg)
 		VERBOSE_PRINTK_STRING("rcu_torture_onoff end holdoff");
 	}
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		cpu = (rcu_random(&rand) >> 4) % (maxcpu + 1);
 		if (cpu_online(cpu) && cpu_is_hotpluggable(cpu)) {
 			if (verbose)
@@ -1530,8 +1548,10 @@ static int rcu_torture_stall(void *args)
 		pr_alert("rcu_torture_stall end.\n");
 	}
 	rcutorture_shutdown_absorb("rcu_torture_stall");
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(10 * HZ);
+	}
 	return 0;
 }
 
@@ -1578,10 +1598,11 @@ static int rcu_torture_barrier_cbs(void
 	VERBOSE_PRINTK_STRING("rcu_torture_barrier_cbs task started");
 	set_user_nice(current, 19);
 	do {
-		wait_event(barrier_cbs_wq[myid],
+		wait_event(barrier_cbs_wq[myid], ({
+			   kgr_task_safe(current);
 			   barrier_phase != lastphase ||
 			   kthread_should_stop() ||
-			   fullstop != FULLSTOP_DONTSTOP);
+			   fullstop != FULLSTOP_DONTSTOP; }));
 		lastphase = barrier_phase;
 		smp_mb(); /* ensure barrier_phase load before ->call(). */
 		if (kthread_should_stop() || fullstop != FULLSTOP_DONTSTOP)
@@ -1592,8 +1613,10 @@ static int rcu_torture_barrier_cbs(void
 	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
 	VERBOSE_PRINTK_STRING("rcu_torture_barrier_cbs task stopping");
 	rcutorture_shutdown_absorb("rcu_torture_barrier_cbs");
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(1);
+	}
 	cur_ops->cb_barrier();
 	destroy_rcu_head_on_stack(&rcu);
 	return 0;
@@ -1612,10 +1635,11 @@ static int rcu_torture_barrier(void *arg
 		barrier_phase = !barrier_phase;
 		for (i = 0; i < n_barrier_cbs; i++)
 			wake_up(&barrier_cbs_wq[i]);
-		wait_event(barrier_wq,
+		wait_event(barrier_wq, ({
+			   kgr_task_safe(current);
 			   atomic_read(&barrier_cbs_count) == 0 ||
 			   kthread_should_stop() ||
-			   fullstop != FULLSTOP_DONTSTOP);
+			   fullstop != FULLSTOP_DONTSTOP; }));
 		if (kthread_should_stop() || fullstop != FULLSTOP_DONTSTOP)
 			break;
 		n_barrier_attempts++;
@@ -1629,8 +1653,10 @@ static int rcu_torture_barrier(void *arg
 	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
 	VERBOSE_PRINTK_STRING("rcu_torture_barrier task stopping");
 	rcutorture_shutdown_absorb("rcu_torture_barrier");
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		schedule_timeout_interruptible(1);
+	}
 	return 0;
 }
 
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -4785,6 +4785,7 @@ static __init int rb_test(void *arg)
 	struct rb_test_data *data = arg;
 
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		rb_write_something(data, false);
 		data->cnt++;
 
@@ -4808,6 +4809,7 @@ static __init void rb_ipi(void *ignore)
 static __init int rb_hammer_test(void *arg)
 {
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 
 		/* Send an IPI to all cpus to write data! */
 		smp_call_function(rb_ipi, NULL, 1);
--- a/kernel/trace/ring_buffer_benchmark.c
+++ b/kernel/trace/ring_buffer_benchmark.c
@@ -370,6 +370,7 @@ static void wait_to_die(void)
 static int ring_buffer_consumer_thread(void *arg)
 {
 	while (!kthread_should_stop() && !kill_test) {
+		kgr_task_safe(current);
 		complete(&read_start);
 
 		ring_buffer_consumer();
@@ -394,6 +395,7 @@ static int ring_buffer_producer_thread(v
 	init_completion(&read_start);
 
 	while (!kthread_should_stop() && !kill_test) {
+		kgr_task_safe(current);
 		ring_buffer_reset(buffer);
 
 		if (consumer) {
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -2442,8 +2442,10 @@ static __init int event_test_thread(void
 	kfree(test_malloc);
 
 	set_current_state(TASK_INTERRUPTIBLE);
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		schedule();
+	}
 
 	return 0;
 }
--- a/kernel/trace/trace_selftest.c
+++ b/kernel/trace/trace_selftest.c
@@ -1039,6 +1039,7 @@ static int trace_wakeup_test_thread(void
 
 	/* we are awake, now wait to disappear */
 	while (!kthread_should_stop()) {
+		kgr_task_safe(current);
 		/*
 		 * This is an RT task, do short sleeps to let
 		 * others run.
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@ -1410,6 +1410,8 @@ static int kmemleak_scan_thread(void *ar
 	while (!kthread_should_stop()) {
 		signed long timeout = jiffies_scan_wait;
 
+		kgr_task_safe(current);
+
 		mutex_lock(&scan_mutex);
 		kmemleak_scan();
 		mutex_unlock(&scan_mutex);
--- a/net/bluetooth/bnep/core.c
+++ b/net/bluetooth/bnep/core.c
@@ -459,6 +459,7 @@ static int bnep_session(void *arg)
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(sk_sleep(sk), &wait);
 	while (1) {
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		if (atomic_read(&s->terminate))
--- a/net/bluetooth/cmtp/core.c
+++ b/net/bluetooth/cmtp/core.c
@@ -289,6 +289,7 @@ static int cmtp_session(void *arg)
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(sk_sleep(sk), &wait);
 	while (1) {
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		if (atomic_read(&session->terminate))
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -1172,6 +1172,7 @@ static void hidp_session_run(struct hidp
 	struct sk_buff *skb;
 
 	for (;;) {
+		kgr_task_safe(current);
 		/*
 		 * This thread can be woken up two ways:
 		 *  - You call hidp_session_terminate() which sets the
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -3424,6 +3424,7 @@ static int pktgen_thread_worker(void *ar
 
 	/* Wait for kthread_stop */
 	for (;;) {
+		kgr_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (kthread_should_stop())
 			break;
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@ -1632,6 +1632,7 @@ static int sync_thread_master(void *data
 		ipvs->master_mcast_ifn, ipvs->master_syncid, tinfo->id);
 
 	for (;;) {
+		kgr_task_safe(current);
 		sb = next_sync_buff(ipvs, ms);
 		if (unlikely(kthread_should_stop()))
 			break;
@@ -1642,9 +1643,10 @@ static int sync_thread_master(void *data
 		while (ip_vs_send_sync_msg(tinfo->sock, sb->mesg) < 0) {
 			int ret = 0;
 
-			__wait_event_interruptible(*sk_sleep(sk),
+			__wait_event_interruptible(*sk_sleep(sk), ({
+						   kgr_task_safe(current);
 						   sock_writeable(sk) ||
-						   kthread_should_stop(),
+						   kthread_should_stop(); }),
 						   ret);
 			if (unlikely(kthread_should_stop()))
 				goto done;
@@ -1686,9 +1688,10 @@ static int sync_thread_backup(void *data
 		ipvs->backup_mcast_ifn, ipvs->backup_syncid, tinfo->id);
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(*sk_sleep(tinfo->sock->sk),
+		wait_event_interruptible(*sk_sleep(tinfo->sock->sk), ({
+			 kgr_task_safe(current);
 			 !skb_queue_empty(&tinfo->sock->sk->sk_receive_queue)
-			 || kthread_should_stop());
+			 || kthread_should_stop(); }));
 
 		/* do we have data now? */
 		while (!skb_queue_empty(&(tinfo->sock->sk->sk_receive_queue))) {
--- a/samples/trace_events/trace-events-sample.c
+++ b/samples/trace_events/trace-events-sample.c
@@ -13,6 +13,7 @@
 
 static void simple_thread_func(int cnt)
 {
+	kgr_task_safe(current);
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout(HZ);
 	trace_foo_bar("hello", cnt);
--- a/sound/pci/emu10k1/emu10k1_main.c
+++ b/sound/pci/emu10k1/emu10k1_main.c
@@ -715,6 +715,7 @@ static int emu1010_firmware_thread(void
 	int err;
 
 	for (;;) {
+		kgr_task_safe(current);
 		/* Delay to allow Audio Dock to settle */
 		msleep_interruptible(1000);
 		if (kthread_should_stop())
