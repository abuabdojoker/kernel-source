From: Petr Mladek <pmladek@suse.com>
Date: Wed, 2 Dec 2015 14:53:19 +0100
Subject: kgr: Remove the confusing search for fentry
Patch-mainline: never, upstream will be different
References: fate#313296

First, the name of ftrace_function_to_fentry() function is confusing.
It returns the address that is modified by ftrace. It is the location
where the function gets redirected to the ftrace handler. The location
and its name is architecture specific. For example, ftrace might use
ftrace or mcount location on x86.

Second, the function was introduced at times when we tried to get kGraft
working with the ftrace handled called from the mcount location.
The function was redirected after the prologue. But the prologue
sometimes was incompatible between the original and the new function.
In this case, the redirection did not work and the system went down.

By other words kGraft works reliably only when the ftrace handler
is called at the beginning of the patched function[*] and the new
function is called from the beginning.

This patch removes the confusing function and all its calls.
The function address is used instead.

It removes the cache for the new function location. The value
is the same as the user-provided function pointer.

The term "function address" is used instead of "fentry" everywhere.
For example, the function kgr_get_fentry_loc() gets renamed to
kgr_get_function_address().

This patch does not modify the existing behavior on both supported
architectures: x86_64 and s390x. ftrace_function_to_fentry() always
returns the function address.

[*] Some instructions might be called before the ftrace handler
but they must be compatible with the epilogue of the new function.
An example is PPC where we first need to set TOC.

Signed-off-by: Petr Mladek <pmladek@suse.com>
Reviewed-by: Miroslav Benes <mbenes@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/ftrace.h |    1 
 include/linux/kgraft.h |    6 +---
 kernel/kgraft.c        |   63 ++++++++++++++++---------------------------------
 kernel/trace/ftrace.c  |   31 ------------------------
 4 files changed, 23 insertions(+), 78 deletions(-)

--- a/include/linux/ftrace.h
+++ b/include/linux/ftrace.h
@@ -300,7 +300,6 @@ extern void
 unregister_ftrace_function_probe_func(char *glob, struct ftrace_probe_ops *ops);
 extern void unregister_ftrace_function_probe_all(char *glob);
 
-extern unsigned long ftrace_function_to_fentry(unsigned long addr);
 extern int ftrace_text_reserved(void *start, void *end);
 
 extern int ftrace_nr_registered_ops(void);
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -37,9 +37,8 @@ struct kgr_patch;
  *
  * @name: function to patch
  * @new_fun: function with the new body
- * @loc_name: cache of @name's fentry
- * @loc_old: cache of the last entry for @name in the patches list
- * @loc_new: cache of @new_name's fentry
+ * @loc_name: cache of @name's function address
+ * @loc_old: cache of the last function address  for @name in the patches list
  * @ftrace_ops_slow: ftrace ops for slow (temporary) stub
  * @ftrace_ops_fast: ftrace ops for fast () stub
  */
@@ -63,7 +62,6 @@ struct kgr_patch_fun {
 
 	unsigned long loc_name;
 	unsigned long loc_old;
-	unsigned long loc_new;
 
 	struct ftrace_ops ftrace_ops_slow;
 	struct ftrace_ops ftrace_ops_fast;
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -67,7 +67,7 @@ static notrace void kgr_stub_fast(unsign
 {
 	struct kgr_patch_fun *p = ops->private;
 
-	kgr_set_regs_ip(regs, p->loc_new);
+	kgr_set_regs_ip(regs, (unsigned long)p->new_fun);
 }
 
 static notrace void kgr_stub_slow(unsigned long ip, unsigned long parent_ip,
@@ -92,7 +92,7 @@ static notrace void kgr_stub_slow(unsign
 	if (go_old)
 		kgr_set_regs_ip(regs, p->loc_old + MCOUNT_INSN_SIZE);
 	else
-		kgr_set_regs_ip(regs, p->loc_new);
+		kgr_set_regs_ip(regs, (unsigned long)p->new_fun);
 }
 
 static void kgr_refs_inc(void)
@@ -372,9 +372,9 @@ static void kgr_wakeup_kthreads(void)
 	read_unlock(&tasklist_lock);
 }
 
-static unsigned long kgr_get_fentry_loc(const struct kgr_patch_fun *pf)
+static unsigned long kgr_get_function_address(const struct kgr_patch_fun *pf)
 {
-	unsigned long orig_addr, fentry_loc;
+	unsigned long orig_addr;
 	const char *check_name;
 	char check_buf[KSYM_SYMBOL_LEN];
 
@@ -385,20 +385,14 @@ static unsigned long kgr_get_fentry_loc(
 		return -ENOENT;
 	}
 
-	fentry_loc = ftrace_function_to_fentry(orig_addr);
-	if (!fentry_loc) {
-		pr_err("kgr: fentry_loc not properly resolved\n");
-		return -ENXIO;
-	}
-
-	check_name = kallsyms_lookup(fentry_loc, NULL, NULL, NULL, check_buf);
+	check_name = kallsyms_lookup(orig_addr, NULL, NULL, NULL, check_buf);
 	if (strcmp(check_name, pf->name)) {
 		pr_err("kgr: we got out of bounds the intended function (%s -> %s)\n",
 				pf->name, check_name);
 		return -EINVAL;
 	}
 
-	return fentry_loc;
+	return orig_addr;
 }
 
 static void kgr_handle_irq_cpu(struct work_struct *work)
@@ -524,7 +518,7 @@ static unsigned long kgr_get_old_fun(con
 	struct kgr_patch_fun *pf = kgr_get_patch_fun(patch_fun, KGR_PREVIOUS);
 
 	if (pf)
-		return ftrace_function_to_fentry((unsigned long)pf->new_fun);
+		return (unsigned long)pf->new_fun;
 
 	return patch_fun->loc_name;
 }
@@ -581,41 +575,26 @@ static int kgr_switch_fops(struct kgr_pa
 static int kgr_init_ftrace_ops(struct kgr_patch_fun *patch_fun)
 {
 	struct ftrace_ops *fops;
-	unsigned long fentry_loc;
-
-	/*
-	 * Initialize the ftrace_ops->private with pointers to the fentry
-	 * sites of both old and new functions. This is used as a
-	 * redirection target in the stubs.
-	 */
-
-	fentry_loc = ftrace_function_to_fentry(
-			((unsigned long)patch_fun->new_fun));
-	if (!fentry_loc) {
-		pr_err("kgr: fentry_loc not properly resolved\n");
-		return -ENXIO;
-	}
+	unsigned long addr;
 
-	pr_debug("kgr: storing %lx to loc_new for %pf\n",
-			fentry_loc, patch_fun->new_fun);
-	patch_fun->loc_new = fentry_loc;
-
-	fentry_loc = kgr_get_fentry_loc(patch_fun);
-	if (IS_ERR_VALUE(fentry_loc))
-		return fentry_loc;
+	/* Cache missing addresses. */
+	addr = kgr_get_function_address(patch_fun);
+	if (IS_ERR_VALUE(addr))
+		return addr;
 
 	pr_debug("kgr: storing %lx to loc_name for %s\n",
-			fentry_loc, patch_fun->name);
-	patch_fun->loc_name = fentry_loc;
+			addr, patch_fun->name);
+	patch_fun->loc_name = addr;
 
-	fentry_loc = kgr_get_old_fun(patch_fun);
-	if (IS_ERR_VALUE(fentry_loc))
-		return fentry_loc;
+	addr = kgr_get_old_fun(patch_fun);
+	if (IS_ERR_VALUE(addr))
+		return addr;
 
 	pr_debug("kgr: storing %lx to loc_old for %s\n",
-			fentry_loc, patch_fun->name);
-	patch_fun->loc_old = fentry_loc;
+			addr, patch_fun->name);
+	patch_fun->loc_old = addr;
 
+	/* Initialize ftrace_ops structures for fast and slow stubs. */
 	fops = &patch_fun->ftrace_ops_fast;
 	fops->private = patch_fun;
 	fops->func = kgr_stub_fast;
@@ -1369,7 +1348,7 @@ static int __init kgr_init(void)
 	int ret;
 
 	if (ftrace_is_dead()) {
-		pr_warn("kgr: enabled, but no fentry locations found ... aborting\n");
+		pr_warn("kgr: enabled, but ftrace is disabled ... aborting\n");
 		return -ENODEV;
 	}
 
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -1513,37 +1513,6 @@ ftrace_ops_test(struct ftrace_ops *ops,
 		}				\
 	}
 
-/**
- * ftrace_function_to_fentry -- lookup fentry location for a function
- * @addr: function address to find a fentry in
- *
- * Perform a lookup in a list of fentry callsites to find one that fits a
- * specified function @addr. It returns the corresponding fentry callsite or
- * zero on failure.
- */
-unsigned long ftrace_function_to_fentry(unsigned long addr)
-{
-	const struct dyn_ftrace *rec;
-	const struct ftrace_page *pg;
-	unsigned long ret = 0;
-
-	mutex_lock(&ftrace_lock);
-	do_for_each_ftrace_rec(pg, rec) {
-		unsigned long off;
-
-		if (!kallsyms_lookup_size_offset(rec->ip, NULL, &off))
-			continue;
-		if (addr + off == rec->ip) {
-			ret = rec->ip;
-			goto end;
-		}
-	} while_for_each_ftrace_rec()
-end:
-	mutex_unlock(&ftrace_lock);
-
-	return ret;
-}
-
 static int ftrace_cmp_recs(const void *a, const void *b)
 {
 	const struct dyn_ftrace *key = a;
