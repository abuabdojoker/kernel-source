From: Jiri Slaby <jslaby@suse.cz>
Date: Wed, 29 Jan 2014 18:22:39 +0100
Subject: kgr: mark task_safe in some kthreads
Patch-mainline: Never, SUSE-Xen specific
References: fate#313296, bnc#890556

Before we enable a kthread support in kGraft, we must make sure all
kthreads mark themselves as kGraft-safe at some point explicitly.

We do this by injecting kgr_task_safe to the freezer test. There, we
assume that kthreads are in some predefined state and can expect
something bad to happen. Hence we switch the kGraft worlds there from
the old one to the new one. The optimal solution would be to convert
most of kthreads (that need not be kthreads actually) to workqeues as
suggested by Tejun. This is an upcoming work that will appear next.
But until we get there, we use freezer for kGraft that way as is
presented here.

Note that there are also some kthreads that do not utilize freezer, so
we use kgr_task_safe in them explicitly. This happens at locations
that appear to be safe for the kthreads to switch the worlds.

The end result after we migrate kthreads (that need not be kthreads)
to workqueues is: have only kthreads that contain kgr_task_safe
explicitly (or using some helper) and nothing else.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org> [devtmpfs]
Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com> [rcu]
Cc: Steven Rostedt <rostedt@goodmis.org>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Ingo Molnar <mingo@redhat.com>
Cc: "Theodore Ts'o" <tytso@mit.edu>
Cc: Dipankar Sarma <dipankar@in.ibm.com>
Cc: Tejun Heo <tj@kernel.org>
Automatically created from "patches.suse/kgr-0009-kgr-mark-task_safe-in-some-kthreads.patch´" by xen-port-patches.py

--- a/drivers/xen/blkback/blkback.c
+++ b/drivers/xen/blkback/blkback.c
@@ -207,10 +207,12 @@ int blkif_schedule(void *arg)
 
 		wait_event_interruptible(
 			blkif->wq,
-			blkif->waiting_reqs || kthread_should_stop());
+			(kgr_task_safe(current),
+			 blkif->waiting_reqs || kthread_should_stop()));
 		wait_event_interruptible(
 			pending_free_wq,
-			!list_empty(&pending_free) || kthread_should_stop());
+			(kgr_task_safe(current),
+			 !list_empty(&pending_free) || kthread_should_stop()));
 
 		blkif->waiting_reqs = 0;
 		smp_mb(); /* clear flag *before* checking for work */
@@ -222,7 +224,8 @@ int blkif_schedule(void *arg)
 			break;
 		case -EACCES:
 			wait_event_interruptible(blkif->shutdown_wq,
-						 kthread_should_stop());
+						 (kgr_task_safe(current),
+						  kthread_should_stop()));
 			break;
 		default:
 			BUG();
@@ -257,6 +260,7 @@ static void drain_io(blkif_t *blkif)
 
 		if (!atomic_read(&blkif->drain))
 			break;
+		kgr_task_safe(current);
 	} while (!kthread_should_stop());
 	atomic_set(&blkif->drain, 0);
 }
--- a/drivers/xen/blktap/blktap.c
+++ b/drivers/xen/blktap/blktap.c
@@ -1174,10 +1174,12 @@ int tap_blkif_schedule(void *arg)
 
 		wait_event_interruptible(
 			blkif->wq,
-			blkif->waiting_reqs || kthread_should_stop());
+			(kgr_task_safe(current),
+			 blkif->waiting_reqs || kthread_should_stop()));
 		wait_event_interruptible(
 			pending_free_wq,
-			!list_empty(&pending_free) || kthread_should_stop());
+			(kgr_task_safe(current),
+			 !list_empty(&pending_free) || kthread_should_stop()));
 
 		blkif->waiting_reqs = 0;
 		smp_mb(); /* clear flag *before* checking for work */
@@ -1189,7 +1191,8 @@ int tap_blkif_schedule(void *arg)
 			break;
 		case -EACCES:
 			wait_event_interruptible(blkif->shutdown_wq,
-						 kthread_should_stop());
+						 (kgr_task_safe(current),
+						  kthread_should_stop()));
 			break;
 		default:
 			BUG();
--- a/drivers/xen/scsiback/scsiback.c
+++ b/drivers/xen/scsiback/scsiback.c
@@ -671,10 +671,12 @@ int scsiback_schedule(void *data)
 	while (!kthread_should_stop()) {
 		wait_event_interruptible(
 			info->wq,
-			info->waiting_reqs || kthread_should_stop());
+			(kgr_task_safe(current),
+			 info->waiting_reqs || kthread_should_stop()));
 		wait_event_interruptible(
 			pending_free_wq,
-			!list_empty(&pending_free) || kthread_should_stop());
+			(kgr_task_safe(current),
+			 !list_empty(&pending_free) || kthread_should_stop()));
 
 		info->waiting_reqs = 0;
 		smp_mb();
@@ -686,7 +688,8 @@ int scsiback_schedule(void *data)
 			break;
 		case -EACCES:
 			wait_event_interruptible(info->shutdown_wq,
-						 kthread_should_stop());
+						 (kgr_task_safe(current),
+						  kthread_should_stop()));
 			break;
 		default:
 			BUG();
--- a/drivers/xen/scsifront/scsifront.c
+++ b/drivers/xen/scsifront/scsifront.c
@@ -268,7 +268,8 @@ int scsifront_schedule(void *data)
 	while (!kthread_should_stop()) {
 		wait_event_interruptible(
 			info->wq,
-			info->waiting_resp || kthread_should_stop());
+			(kgr_task_safe(current),
+			 info->waiting_resp || kthread_should_stop()));
 
 		info->waiting_resp = 0;
 		smp_mb();
--- a/drivers/xen/usbback/usbback.c
+++ b/drivers/xen/usbback/usbback.c
@@ -1121,10 +1121,12 @@ int usbbk_schedule(void *arg)
 	while (!kthread_should_stop()) {
 		wait_event_interruptible(
 			usbif->wq,
-			usbif->waiting_reqs || kthread_should_stop());
+			(kgr_task_safe(current),
+			 usbif->waiting_reqs || kthread_should_stop()));
 		wait_event_interruptible(
 			pending_free_wq,
-			!list_empty(&pending_free) || kthread_should_stop());
+			(kgr_task_safe(current),
+			 !list_empty(&pending_free) || kthread_should_stop()));
 		usbif->waiting_reqs = 0;
 		smp_mb();
 
@@ -1135,7 +1137,8 @@ int usbbk_schedule(void *arg)
 			break;
 		case -EACCES:
 			wait_event_interruptible(usbif->shutdown_wq,
-						 kthread_should_stop());
+						 (kgr_task_safe(current),
+						  kthread_should_stop()));
 			break;
 		default:
 			BUG();
--- a/drivers/xen/usbfront/usbfront-q.c
+++ b/drivers/xen/usbfront/usbfront-q.c
@@ -516,7 +516,8 @@ int xenhcd_schedule(void *arg)
 	while (!kthread_should_stop()) {
 		wait_event_interruptible(
 				info->wq,
-				info->waiting_resp || kthread_should_stop());
+				(kgr_task_safe(current),
+				 info->waiting_resp || kthread_should_stop()));
 		info->waiting_resp = 0;
 		smp_mb();
 
--- a/drivers/xen/xenbus/xenbus_comms.c
+++ b/drivers/xen/xenbus/xenbus_comms.c
@@ -180,7 +180,9 @@ int xb_data_to_read(void)
 
 int xb_wait_for_data_to_read(void)
 {
-	return wait_event_interruptible(xb_waitq, xb_data_to_read());
+	return wait_event_interruptible(xb_waitq,
+					(kgr_task_safe(current),
+					 xb_data_to_read()));
 }
 
 int xb_read(void *data, unsigned len)
