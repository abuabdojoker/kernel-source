From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 23 Nov 2016 15:12:26 +0100
Subject: [PATCH] i2c: designware-baytrail: Work around Cherry Trail semaphore
 errors
Patch-mainline: Not yet, temporary workaround for Wyse preload
References: bsc#1011913

i2c-baytrail semaphore doesn't seem work on Cherry Trail at all, and
it always leads to the timeout error.  Looking through the web,
someone mentioned about PUNIT address changes from 0x07 for BYT to
0x10e for CHT.  And indeed it seems working on a test system here.

This patch addresses the issue on CHT by using a different semaphore
address depending on the chip.  The CHT system gets identified from
the cpu_id matching (family 6, model 76).

Bugzilla: https://bugzilla.opensuse.org/show_bug.cgi?id=1011913
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/i2c/busses/i2c-designware-baytrail.c |   28 +++++++++++++++++++++------
 1 file changed, 22 insertions(+), 6 deletions(-)

--- a/drivers/i2c/busses/i2c-designware-baytrail.c
+++ b/drivers/i2c/busses/i2c-designware-baytrail.c
@@ -19,14 +19,16 @@
 #include <linux/interrupt.h>
 
 #include <asm/iosf_mbi.h>
+#include <asm/cpu_device_id.h>
 
 #include "i2c-designware-core.h"
 
 #define SEMAPHORE_TIMEOUT	100
-#define PUNIT_SEMAPHORE		0x7
 #define PUNIT_SEMAPHORE_BIT	BIT(0)
 #define PUNIT_SEMAPHORE_ACQUIRE	BIT(1)
 
+static int punit_semaphore = 0x07;
+
 static unsigned long acquired;
 
 static int get_sem(struct device *dev, u32 *sem)
@@ -34,7 +36,7 @@ static int get_sem(struct device *dev, u
 	u32 data;
 	int ret;
 
-	ret = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ, PUNIT_SEMAPHORE,
+	ret = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ, punit_semaphore,
 				&data);
 	if (ret) {
 		dev_err(dev, "iosf failed to read punit semaphore\n");
@@ -51,14 +53,14 @@ static void reset_semaphore(struct devic
 	u32 data;
 
 	if (iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,
-				PUNIT_SEMAPHORE, &data)) {
+				punit_semaphore, &data)) {
 		dev_err(dev, "iosf failed to reset punit semaphore during read\n");
 		return;
 	}
 
 	data &= ~PUNIT_SEMAPHORE_BIT;
 	if (iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,
-				PUNIT_SEMAPHORE, data))
+				punit_semaphore, data))
 		dev_err(dev, "iosf failed to reset punit semaphore during write\n");
 }
 
@@ -78,7 +80,7 @@ static int baytrail_i2c_acquire(struct d
 
 	/* host driver writes to side band semaphore register */
 	ret = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,
-				PUNIT_SEMAPHORE, PUNIT_SEMAPHORE_ACQUIRE);
+				punit_semaphore, PUNIT_SEMAPHORE_ACQUIRE);
 	if (ret) {
 		dev_err(dev->dev, "iosf punit semaphore request failed\n");
 		return ret;
@@ -103,7 +105,7 @@ static int baytrail_i2c_acquire(struct d
 	reset_semaphore(dev->dev);
 
 	ret = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,
-				PUNIT_SEMAPHORE, &sem);
+				punit_semaphore, &sem);
 	if (ret)
 		dev_err(dev->dev, "iosf failed to read punit semaphore\n");
 	else
@@ -127,6 +129,16 @@ static void baytrail_i2c_release(struct
 		jiffies_to_msecs(jiffies - acquired));
 }
 
+static bool is_cherrytrail(void)
+{
+	static const struct x86_cpu_id cpu_ids[] = {
+		{ X86_VENDOR_INTEL, 6, 76 },
+		{}
+	};
+
+	return x86_match_cpu(cpu_ids);
+}
+
 int i2c_dw_eval_lock_support(struct dw_i2c_dev *dev)
 {
 	acpi_status status;
@@ -149,6 +161,10 @@ int i2c_dw_eval_lock_support(struct dw_i
 		dev->acquire_lock = baytrail_i2c_acquire;
 		dev->release_lock = baytrail_i2c_release;
 		dev->pm_runtime_disabled = true;
+		if (is_cherrytrail()) {
+			dev_info(dev->dev, "Using semaphore reg 0x10e for Cherry Trail\n");
+			punit_semaphore = 0x10e;
+		}
 	}
 
 	if (!iosf_mbi_available())
