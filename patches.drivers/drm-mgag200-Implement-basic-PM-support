From 0525ea3e72b71884e3f3d3a782a58af114dd57e0 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 29 Apr 2014 17:41:27 +0200
Subject: [PATCH] drm/mgag200: Implement basic PM support
References: bnc#872213
Patch-mainline: Submitted

Add a basic PM support to mgag200 driver.
As there is no hardware specific init codes for this device, the
callbacks are written in a fairly simple way.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/mgag200/mgag200_drv.c |   75 ++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/mgag200/mgag200_drv.h |    1 
 drivers/gpu/drm/mgag200/mgag200_fb.c  |    5 ++
 3 files changed, 81 insertions(+)

--- a/drivers/gpu/drm/mgag200/mgag200_drv.c
+++ b/drivers/gpu/drm/mgag200/mgag200_drv.c
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/console.h>
 #include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
 
 #include "mgag200_drv.h"
 
@@ -74,6 +75,79 @@ static void mga_pci_remove(struct pci_de
 	drm_put_dev(dev);
 }
 
+static int mgag200_pm_freeze(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+	struct mga_device *mdev = drm_dev->dev_private;
+	struct drm_connector *connector;
+
+	drm_kms_helper_poll_disable(drm_dev);
+	list_for_each_entry(connector, &drm_dev->mode_config.connector_list,
+			    head)
+		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
+
+	console_lock();
+	mgag200_fbdev_set_suspend(mdev, FBINFO_STATE_SUSPENDED);
+	console_unlock();
+
+	return 0;
+}
+
+static int mgag200_pm_thaw(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+	struct mga_device *mdev = drm_dev->dev_private;
+	struct drm_connector *connector;
+
+	console_lock();
+	mgag200_fbdev_set_suspend(mdev, FBINFO_STATE_RUNNING);
+	console_unlock();
+
+	drm_helper_resume_force_mode(drm_dev);
+	list_for_each_entry(connector, &drm_dev->mode_config.connector_list,
+			    head)
+		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
+
+	drm_kms_helper_poll_enable(drm_dev);
+	return 0;
+}
+
+static int mgag200_pm_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	int err;
+
+	err = mgag200_pm_freeze(dev);
+	if (err)
+		return err;
+
+	pci_save_state(pdev);
+	pci_disable_device(pdev);
+	pci_set_power_state(pdev, PCI_D3hot);
+	return 0;
+}
+
+static int mgag200_pm_resume(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+	if (pci_enable_device(pdev))
+		return -EIO;
+
+	return mgag200_pm_thaw(dev);
+}
+
+static const struct dev_pm_ops mgag200_pm_ops = {
+	.suspend = mgag200_pm_suspend,
+	.resume = mgag200_pm_resume,
+	.freeze = mgag200_pm_freeze,
+	.thaw = mgag200_pm_thaw,
+	.poweroff = mgag200_pm_freeze,
+	.restore = mgag200_pm_resume,
+};
+
 static const struct file_operations mgag200_driver_fops = {
 	.owner = THIS_MODULE,
 	.open = drm_open,
@@ -111,6 +185,7 @@ static struct pci_driver mgag200_pci_dri
 	.id_table = pciidlist,
 	.probe = mga_pci_probe,
 	.remove = mga_pci_remove,
+	.driver.pm = &mgag200_pm_ops,
 };
 
 static int __init mgag200_init(void)
--- a/drivers/gpu/drm/mgag200/mgag200_drv.h
+++ b/drivers/gpu/drm/mgag200/mgag200_drv.h
@@ -247,6 +247,7 @@ void mgag200_modeset_fini(struct mga_dev
 				/* mgag200_fb.c */
 int mgag200_fbdev_init(struct mga_device *mdev);
 void mgag200_fbdev_fini(struct mga_device *mdev);
+void mgag200_fbdev_set_suspend(struct mga_device *mdev, int state);
 void mgag200_fbdev_set_base(struct mga_device *mdev, unsigned long gpu_addr);
 
 				/* mgag200_main.c */
--- a/drivers/gpu/drm/mgag200/mgag200_fb.c
+++ b/drivers/gpu/drm/mgag200/mgag200_fb.c
@@ -331,3 +331,8 @@ void mgag200_fbdev_set_base(struct mga_d
 		mdev->mfbdev->helper.fbdev->apertures->ranges[0].base + gpu_addr;
 	mdev->mfbdev->helper.fbdev->fix.smem_len = mdev->mc.vram_size - gpu_addr;
 }
+
+void mgag200_fbdev_set_suspend(struct mga_device *mdev, int state)
+{
+	fb_set_suspend(mdev->mfbdev->helper.fbdev, state);
+}
