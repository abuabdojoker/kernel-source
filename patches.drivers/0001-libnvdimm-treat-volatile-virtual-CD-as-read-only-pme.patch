From 49d3ad111af6b5155aef5fc84c77e0ba5fcdcc9f Mon Sep 17 00:00:00 2001
From: "Lee, Chun-Yi" <jlee@suse.com>
Date: Sat, 30 Apr 2016 00:18:51 +0800
Subject: [PATCH 1/2] libnvdimm, nfit: treat volatile virtual CD as read-only pmem

Patch-mainline: Not yet, will send to kernel upstream
References: fate#320134
Target: SLE-12 SP2

This patch adds logic to libnvdimm to treat a volatile virtual CD
region as a read-only pmem region, then the read-only /dev/pmem*
can be mounted with iso9660.

It's useful to work with httpboot function in EFI firmware to pull
a remote ISO file to a local memory region for booting.

Signed-off-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/acpi/nfit.c          |    8 +++++++-
 drivers/nvdimm/region_devs.c |   26 +++++++++++++++++++++++++-
 include/linux/libnvdimm.h    |    2 ++
 3 files changed, 34 insertions(+), 2 deletions(-)

--- a/drivers/acpi/nfit.c
+++ b/drivers/acpi/nfit.c
@@ -1725,6 +1725,7 @@ static int acpi_nfit_init_mapping(struct
 	switch (nfit_spa_type(spa)) {
 	case NFIT_SPA_PM:
 	case NFIT_SPA_VOLATILE:
+	case NFIT_SPA_VCD:
 		nd_mapping->start = memdev->address;
 		nd_mapping->size = memdev->region_size;
 		break;
@@ -1771,7 +1772,7 @@ static int acpi_nfit_register_region(str
 	if (nfit_spa->nd_region)
 		return 0;
 
-	if (spa->range_index == 0) {
+	if (spa->range_index == 0 && nfit_spa_type(spa) != NFIT_SPA_VCD) {
 		dev_dbg(acpi_desc->dev, "%s: detected invalid spa index\n",
 				__func__);
 		return 0;
@@ -1830,6 +1831,11 @@ static int acpi_nfit_register_region(str
 				ndr_desc);
 		if (!nfit_spa->nd_region)
 			rc = -ENOMEM;
+	} else if (nfit_spa_type(spa) == NFIT_SPA_VCD) {
+		nfit_spa->nd_region = nvdimm_vcd_region_create(nvdimm_bus,
+				ndr_desc);
+		if (!nfit_spa->nd_region)
+			rc = -ENOMEM;
 	} else if (nfit_spa_type(spa) == NFIT_SPA_VOLATILE) {
 		nfit_spa->nd_region = nvdimm_volatile_region_create(nvdimm_bus,
 				ndr_desc);
--- a/drivers/nvdimm/region_devs.c
+++ b/drivers/nvdimm/region_devs.c
@@ -56,9 +56,19 @@ static struct device_type nd_volatile_de
 	.release = nd_region_release,
 };
 
+static struct device_type nd_vcd_device_type = {
+	.name = "nd_vcd",
+	.release = nd_region_release,
+};
+
+bool is_nd_vcd(struct device *dev)
+{
+	return dev ? dev->type == &nd_vcd_device_type : false;
+}
+
 bool is_nd_pmem(struct device *dev)
 {
-	return dev ? dev->type == &nd_pmem_device_type : false;
+	return dev ? dev->type == &nd_pmem_device_type || is_nd_vcd(dev) : false;
 }
 
 bool is_nd_blk(struct device *dev)
@@ -321,6 +331,9 @@ static ssize_t read_only_store(struct de
 	int rc = strtobool(buf, &ro);
 	struct nd_region *nd_region = to_nd_region(dev);
 
+	if (is_nd_vcd(dev))
+		return -ENXIO;
+
 	if (rc)
 		return rc;
 
@@ -659,6 +672,9 @@ static struct nd_region *nd_region_creat
 			ro = 1;
 	}
 
+	if (dev_type == &nd_vcd_device_type)
+		ro = 1;
+
 	if (dev_type == &nd_blk_device_type) {
 		struct nd_blk_region_desc *ndbr_desc;
 		struct nd_blk_region *ndbr;
@@ -745,6 +761,14 @@ struct nd_region *nvdimm_pmem_region_cre
 }
 EXPORT_SYMBOL_GPL(nvdimm_pmem_region_create);
 
+struct nd_region *nvdimm_vcd_region_create(struct nvdimm_bus *nvdimm_bus,
+		struct nd_region_desc *ndr_desc)
+{
+	return nd_region_create(nvdimm_bus, ndr_desc, &nd_vcd_device_type,
+			__func__);
+}
+EXPORT_SYMBOL_GPL(nvdimm_vcd_region_create);
+
 struct nd_region *nvdimm_blk_region_create(struct nvdimm_bus *nvdimm_bus,
 		struct nd_region_desc *ndr_desc)
 {
--- a/include/linux/libnvdimm.h
+++ b/include/linux/libnvdimm.h
@@ -144,6 +144,8 @@ u32 nd_cmd_out_size(struct nvdimm *nvdim
 int nvdimm_bus_check_dimm_count(struct nvdimm_bus *nvdimm_bus, int dimm_count);
 struct nd_region *nvdimm_pmem_region_create(struct nvdimm_bus *nvdimm_bus,
 		struct nd_region_desc *ndr_desc);
+struct nd_region *nvdimm_vcd_region_create(struct nvdimm_bus *nvdimm_bus,
+		struct nd_region_desc *ndr_desc);
 struct nd_region *nvdimm_blk_region_create(struct nvdimm_bus *nvdimm_bus,
 		struct nd_region_desc *ndr_desc);
 struct nd_region *nvdimm_volatile_region_create(struct nvdimm_bus *nvdimm_bus,
