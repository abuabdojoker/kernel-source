From: Thomas Hellström <thellstrom@vmware.com>
Date: Mon Nov 30 12:14:35 2015 +0100
Subject: drm: Allocate new master object when client becomes master
Patch-mainline: not yet, patch handled by Thomas Hellström <thellstrom@vmware.com>
References: bsc#956876, bsc#956801

When a drm master has dropped it's master privileges, a drm client
can request it. If it becomes master inheriting the master objects
of the old master it will gain access to all clients of this master.
The vmwgfx driver caught this condition and thru a kernel BUG.

Signed-off-by: Egbert Eich <eich@suse.de>
Signed-off-by: Egbert Eich <eich@suse.com>
---
 drivers/gpu/drm/drm_fops.c | 95 ++++++++++++++++++++++++++++------------------
 drivers/gpu/drm/drm_stub.c | 19 ++++++++++
 include/drm/drmP.h         |  3 ++
 3 files changed, 80 insertions(+), 37 deletions(-)
diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c
index 3f84277..b029413 100644
--- a/drivers/gpu/drm/drm_fops.c
+++ b/drivers/gpu/drm/drm_fops.c
@@ -198,6 +198,59 @@ static int drm_cpu_valid(void)
 }
 
 /**
+ * drm_new_set_master - Allocate a new master object and become master for the
+ * associated master realm.
+ *
+ * @dev: The associated device.
+ * @fpriv: File private identifying the client.
+ *
+ * This function must be called with dev::struct_mutex held. Returns negative
+ * error code on failure, zero oun success.
+ */
+int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv)
+{
+	int ret;
+
+	lockdep_assert_held(&dev->struct_mutex);
+	/* create a new master */
+	fpriv->minor->master = drm_master_create(fpriv->minor);
+	if (!fpriv->minor->master)
+		return -ENOMEM;
+
+	fpriv->is_master = 1;
+	fpriv->allowed_master = true;
+
+	/* take another reference for the copy in the local file priv */
+	fpriv->master = drm_master_get(fpriv->minor->master);
+
+	fpriv->authenticated = 1;
+
+	if (dev->driver->master_create) {
+		mutex_unlock(&dev->struct_mutex);
+		ret = dev->driver->master_create(dev, fpriv->master);
+		mutex_lock(&dev->struct_mutex);
+		if (ret) {
+			/* drop both references if this fails */
+			drm_master_put(&fpriv->minor->master);
+			drm_master_put(&fpriv->master);
+			return ret;
+		}
+	}
+	if (dev->driver->master_set) {
+		ret = dev->driver->master_set(dev, fpriv, true);
+		if (ret) {
+			/* drop both references if this fails */
+			drm_master_put(&fpriv->minor->master);
+			drm_master_put(&fpriv->master);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+
+/**
  * Called whenever a process opens /dev/drm.
  *
  * \param inode device inode.
@@ -213,7 +266,7 @@ static int drm_open_helper(struct inode *inode, struct file *filp,
 {
 	int minor_id = iminor(inode);
 	struct drm_file *priv;
-	int ret;
+	int ret = 0;
 
 	if (filp->f_flags & O_EXCL)
 		return -EBUSY;	/* No exclusive opens */
@@ -267,47 +320,15 @@ static int drm_open_helper(struct inode *inode, struct file *filp,
 	mutex_lock(&dev->struct_mutex);
 	if (!priv->minor->master && !drm_is_render_client(priv)) {
 		/* create a new master */
-		priv->minor->master = drm_master_create(priv->minor);
-		if (!priv->minor->master) {
-			mutex_unlock(&dev->struct_mutex);
-			ret = -ENOMEM;
-			goto out_close;
-		}
-
-		priv->is_master = 1;
-		/* take another reference for the copy in the local file priv */
-		priv->master = drm_master_get(priv->minor->master);
-
-		priv->authenticated = 1;
-
-		mutex_unlock(&dev->struct_mutex);
-		if (dev->driver->master_create) {
-			ret = dev->driver->master_create(dev, priv->master);
-			if (ret) {
-				mutex_lock(&dev->struct_mutex);
-				/* drop both references if this fails */
-				drm_master_put(&priv->minor->master);
-				drm_master_put(&priv->master);
-				mutex_unlock(&dev->struct_mutex);
-				goto out_close;
-			}
-		}
-		mutex_lock(&dev->struct_mutex);
-		if (dev->driver->master_set) {
-			ret = dev->driver->master_set(dev, priv, true);
-			if (ret) {
-				/* drop both references if this fails */
-				drm_master_put(&priv->minor->master);
-				drm_master_put(&priv->master);
-				mutex_unlock(&dev->struct_mutex);
-				goto out_close;
-			}
-		}
+		ret = drm_new_set_master(dev, priv);
 	} else if (!drm_is_render_client(priv)) {
 		/* get a reference to the master */
 		priv->master = drm_master_get(priv->minor->master);
 	}
 	mutex_unlock(&dev->struct_mutex);
+	if (ret)
+		goto out_close;
+
 
 	mutex_lock(&dev->struct_mutex);
 	list_add(&priv->lhead, &dev->filelist);
diff --git a/drivers/gpu/drm/drm_stub.c b/drivers/gpu/drm/drm_stub.c
index 39d8645..471a755 100644
--- a/drivers/gpu/drm/drm_stub.c
+++ b/drivers/gpu/drm/drm_stub.c
@@ -222,6 +222,25 @@ int drm_setmaster_ioctl(struct drm_device *dev, void *data,
 		return -EINVAL;
 
 	mutex_lock(&dev->struct_mutex);
+
+	/*
+	 * If this file_priv is not allowed to gain master privileges for
+	 * file_priv::master, allocate a new master and start a new master
+	 * realm.
+	 */
+	if (!file_priv->allowed_master) {
+		struct drm_master *saved_master = file_priv->master;
+
+		ret = drm_new_set_master(dev, file_priv);
+		if (ret)
+			file_priv->master = saved_master;
+		else
+			drm_master_put(&saved_master);
+
+		mutex_unlock(&dev->struct_mutex);
+		return ret;
+	}
+
 	file_priv->minor->master = drm_master_get(file_priv->master);
 	file_priv->is_master = 1;
 	if (dev->driver->master_set) {
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index b46fb45..55937fc 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -430,6 +430,8 @@ struct drm_file {
 	void *driver_priv;
 
 	int is_master; /* this file private is a master for a minor */
+	/* this client is allowed to gain master privileges for @master */
+	bool allowed_master;
 	struct drm_master *master; /* master this node is currently associated with
 				      N.B. not always minor->master */
 
@@ -1277,6 +1279,7 @@ extern int drm_stub_open(struct inode *inode, struct file *filp);
 extern ssize_t drm_read(struct file *filp, char __user *buffer,
 			size_t count, loff_t *offset);
 extern int drm_release(struct inode *inode, struct file *filp);
+extern int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv);
 
 				/* Mapping support (drm_vm.h) */
 extern int drm_mmap(struct file *filp, struct vm_area_struct *vma);
