From: Sebastian Ott <sebott@linux.vnet.ibm.com>
Subject: s390/pci_dma: unify label of invalid translation table entries
Patch-mainline: v4.4-rc2
Git-commit: 4d5a6b72959601d6c12e7e1ef3aa4132f0a62523
References: bnc#974692, LTC#139442

Description:  s390/pci: fix unhandled failures during dma table updates
Symptom:      Unusable PCI functions
Problem:      Allocation (and other) failures during translation table updates
              are not handled.
Solution:     Handle these failures and undo translation table updates when it
              is meaningful.
Reproduction: PCI hotplug vs. driver initialization or workload.

Upstream-Description:

              s390/pci_dma: unify label of invalid translation table entries

              Newly allocated translation table entries are flagged as invalid
              and protected. If an existing translation table entry is invalidated,
              the protection flag is left unchanged.

              If a page (with invalid and protection flag set) is accessed it's
              undefined which type of exception we'll receive.

              Make sure to always set the invalid flag only.

              Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
              Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/pci/pci_dma.c |    7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

--- a/arch/s390/pci/pci_dma.c
+++ b/arch/s390/pci/pci_dma.c
@@ -33,7 +33,7 @@ static unsigned long *dma_alloc_cpu_tabl
 		return NULL;
 
 	for (entry = table; entry < table + ZPCI_TABLE_ENTRIES; entry++)
-		*entry = ZPCI_TABLE_INVALID | ZPCI_TABLE_PROTECTED;
+		*entry = ZPCI_TABLE_INVALID;
 	return table;
 }
 
@@ -51,7 +51,7 @@ static unsigned long *dma_alloc_page_tab
 		return NULL;
 
 	for (entry = table; entry < table + ZPCI_PT_ENTRIES; entry++)
-		*entry = ZPCI_PTE_INVALID | ZPCI_TABLE_PROTECTED;
+		*entry = ZPCI_PTE_INVALID;
 	return table;
 }
 
@@ -127,7 +127,6 @@ static void dma_update_cpu_trans(struct
 
 	if (flags & ZPCI_PTE_INVALID) {
 		invalidate_pt_entry(entry);
-		return;
 	} else {
 		set_pt_pfaa(entry, page_addr);
 		validate_pt_entry(entry);
@@ -323,7 +322,7 @@ static void s390_dma_unmap_pages(struct
 	npages = iommu_num_pages(dma_addr, size, PAGE_SIZE);
 	dma_addr = dma_addr & PAGE_MASK;
 	if (dma_update_trans(zdev, 0, dma_addr, npages * PAGE_SIZE,
-			     ZPCI_TABLE_PROTECTED | ZPCI_PTE_INVALID)) {
+			     ZPCI_PTE_INVALID)) {
 		zpci_err("unmap error:\n");
 		zpci_err_hex(&dma_addr, sizeof(dma_addr));
 	}
