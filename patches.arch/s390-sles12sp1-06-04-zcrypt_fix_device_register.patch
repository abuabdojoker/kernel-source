From: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Subject: s390/zcrypt: HWRNG registration cause kernel panic on CEX hotplug
Patch-mainline: Never, SUSE only
References: bnc#968497, LTC#138409

Description:  s390/zcrypt: HWRNG registration cause kernel panic on CEX hotplug
Symptom:      A kernel panic may occur when hot-plugging CCA coprocessor
              adapters while the zcrypt device driver is loaded.
Problem:      There is a race between the ap device registration and the
              device probing. Very early hwrng requests called directly
              on hwrng_register (during device probing) trying to access
              a non registered ap devices, that finally leads to device
              unregister/deletion although the kernel doesn't have fully
              registered this device.
Solution:     Prevent the race by introducing a new registration state
              within the ap device structure. Requests are only permitted
              if the device probing and registration is fully completed.
Reproduction: Load the zcrypt DD (ap module). Configure off/on a CCA
              coprocessor adapter within your LPAR / zVM guest.


Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/crypto/ap_bus.c |   27 +++++++++++++++++----------
 drivers/s390/crypto/ap_bus.h |    7 +++++++
 2 files changed, 24 insertions(+), 10 deletions(-)

--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@ -872,7 +872,7 @@ static int ap_bus_suspend(struct device
 	} while ((flags & 1) || (flags & 2));
 
 	spin_lock_bh(&ap_dev->lock);
-	ap_dev->unregistered = 1;
+	ap_dev->unregistered = AP_DEV_UNREGISTERED;
 	spin_unlock_bh(&ap_dev->lock);
 
 	return 0;
@@ -1468,9 +1468,10 @@ static void ap_scan_bus(struct work_stru
 		if (dev) {
 			ap_dev = to_ap_dev(dev);
 			spin_lock_bh(&ap_dev->lock);
-			if (rc == -ENODEV || ap_dev->unregistered) {
+			if (rc == -ENODEV ||
+			    ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 				spin_unlock_bh(&ap_dev->lock);
-				if (ap_dev->unregistered)
+				if (ap_dev->unregistered == AP_DEV_UNREGISTERED)
 					i--;
 				device_unregister(dev);
 				put_device(dev);
@@ -1492,7 +1493,7 @@ static void ap_scan_bus(struct work_stru
 			continue;
 		}
 		ap_dev->queue_depth = queue_depth;
-		ap_dev->unregistered = 1;
+		ap_dev->unregistered = AP_DEV_REGIST_IN_PROGRESS;
 		spin_lock_init(&ap_dev->lock);
 		INIT_LIST_HEAD(&ap_dev->pendingq);
 		INIT_LIST_HEAD(&ap_dev->requestq);
@@ -1536,7 +1537,7 @@ static void ap_scan_bus(struct work_stru
 					&ap_dev_attr_group);
 		if (!rc) {
 			spin_lock_bh(&ap_dev->lock);
-			ap_dev->unregistered = 0;
+			ap_dev->unregistered = AP_DEV_REGISTERED;
 			spin_unlock_bh(&ap_dev->lock);
 		}
 		else
@@ -1784,10 +1785,13 @@ void ap_queue_message(struct ap_device *
 		if (!rc)
 			wake_up(&ap_poll_wait);
 		if (rc == -ENODEV)
-			ap_dev->unregistered = 1;
-	} else {
+			ap_dev->unregistered = AP_DEV_UNREGISTERED;
+	} else if (ap_dev->unregistered == AP_DEV_UNREGISTERED) {
 		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));
 		rc = -ENODEV;
+	} else { /* device registration in progress */
+		ap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EBUSY));
+		rc = -EBUSY;
 	}
 	spin_unlock_bh(&ap_dev->lock);
 	if (rc == -ENODEV)
@@ -1854,16 +1858,19 @@ static void ap_reset(struct ap_device *a
 	ap_dev->pendingq_count = 0;
 	rc = ap_init_queue(ap_dev);
 	if (rc == -ENODEV)
-		ap_dev->unregistered = 1;
+		ap_dev->unregistered = AP_DEV_UNREGISTERED;
 	else
 		*flags |= AP_POLL_AFTER_TIMEOUT;
 }
 
 static int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags)
 {
+	int rc;
+
 	if (!ap_dev->unregistered) {
-		if (ap_poll_queue(ap_dev, flags))
-			ap_dev->unregistered = 1;
+		rc = ap_poll_queue(ap_dev, flags);
+		if (rc == -ENODEV)
+			ap_dev->unregistered = AP_DEV_UNREGISTERED;
 		if (ap_dev->reset == AP_RESET_DO)
 			ap_reset(ap_dev, flags);
 	}
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -147,6 +147,13 @@ static inline int ap_test_bit(unsigned i
 #define AP_INTR_ENABLED		1	/* AP interrupt enabled */
 #define AP_INTR_IN_PROGRESS	3	/* AP interrupt in progress */
 
+/*
+ * AP device registration states
+ */
+#define AP_DEV_UNREGISTERED		2 /* unregistered or orphaned device */
+#define AP_DEV_REGIST_IN_PROGRESS	1 /* device registration in progress */
+#define AP_DEV_REGISTERED		0 /* device fully registered */
+
 struct ap_device;
 struct ap_message;
 
