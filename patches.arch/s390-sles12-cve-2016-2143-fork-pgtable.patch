From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: s390/mm: four page table levels vs. fork
Patch-mainline: Queued
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
Git-commit: 3446c13b268af86391d06611327006b059b8bab1
References: bnc#970504, LTC#138810, CVE-2016-2143

Description:  kernel: fork of a large process causes memory corruption
Symptom:      The fork of a process with four page table levels will
              cause memory corruption with a variety of symptoms.
Problem:      All processes are created with a three level page table
              and an limit of 4TB for the address space. If the parent
              process has four page table levels with a limit of 8PB
              the function that duplicates the address space will try
              to copy memory areas outside of the address space limit
              for the child process. This leads to memory clobbers.
Solution:     Create the child process with the same number of page
              table levels as the parent.
Reproduction: Map a large memory area with the mmap() call and then
              call fork().

Upstream-Description:

              s390/mm: four page table levels vs. fork

              The fork of a process with four page table levels is broken since
              git commit 6252d702c5311ce9 "[S390] dynamic page tables."

              All new mm contexts are created with three page table levels and
              an asce limit of 4TB. If the parent has four levels dup_mmap will
              add vmas to the new context which are outside of the asce limit.
              The subsequent call to copy_page_range will walk the three level
              page table structure of the new process with non-zero pgd and pud
              indexes. This leads to memory clobbers as the pgd_index *and* the
              pud_index is added to the mm->pgd pointer without a pgd_deref
              in between.

              The init_new_context() function is selecting the number of page
              table levels for a new context. The function is used by mm_init()
              which in turn is called by dup_mm() and mm_alloc(). These two are
              used by fork() and exec(). The init_new_context() function can
              distinguish the two cases by looking at mm->context.asce_limit,
              for fork() the mm struct has been copied and the number of page
              table levels may not change. For exec() the mm_alloc() function
              set the new mm structure to zero, in this case a three-level page
              table is created as the temporary stack space is located at
              STACK_TOP_MAX = 4TB.

              This fixes CVE-2016-2143.

              Reported-by: Marcin Ko≈õcielnicki <koriakin@0x04.net>
              Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
              Cc: stable@vger.kernel.org
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.com>
---
 arch/s390/include/asm/mmu_context.h |   15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

--- a/arch/s390/include/asm/mmu_context.h
+++ b/arch/s390/include/asm/mmu_context.h
@@ -17,12 +17,15 @@ static inline int init_new_context(struc
 {
 	atomic_set(&mm->context.attach_count, 0);
 	mm->context.flush_mm = 0;
-	mm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;
+	mm->context.has_pgste = 0;
+	if (mm->context.asce_limit == 0) {
+		/* context created by exec, set asce limit to 4TB */
+		mm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;
 #ifdef CONFIG_64BIT
-	mm->context.asce_bits |= _ASCE_TYPE_REGION3;
+		mm->context.asce_bits |= _ASCE_TYPE_REGION3;
 #endif
-	mm->context.has_pgste = 0;
-	mm->context.asce_limit = STACK_TOP_MAX;
+		mm->context.asce_limit = STACK_TOP_MAX;
+	}
 	crst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));
 	return 0;
 }
@@ -72,10 +75,6 @@ static inline void activate_mm(struct mm
 static inline void arch_dup_mmap(struct mm_struct *oldmm,
 				 struct mm_struct *mm)
 {
-#ifdef CONFIG_64BIT
-	if (oldmm->context.asce_limit < mm->context.asce_limit)
-		crst_table_downgrade(mm, oldmm->context.asce_limit);
-#endif
 }
 
 static inline void arch_exit_mmap(struct mm_struct *mm)
