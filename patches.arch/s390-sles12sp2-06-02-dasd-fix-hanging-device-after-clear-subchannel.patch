From: Stefan Haberland <sth@linux.vnet.ibm.com>
Subject: s390/dasd: fix hanging device after clear subchannel
Patch-mainline: v4.8-rc3
Git-commit: 9ba333dc55cbb9523553df973adb3024d223e905
References: bnc#994430, LTC#144640

Description:  dasd: Fix hanging device after clear subchannel.
Symptom:      Hanging DASD device after clear subchannel command
              caused by path events for example.
Problem:      When a device is in a status where CIO has killed all
              I/O by itself the interrupt for a clear request may not
              contain an irb to determine the clear function. Instead
              it contains an error pointer -EIO. This was ignored by
              the DASD int_handler leading to a hanging device waiting
              for a clear interrupt.
Solution:     Handle -EIO error pointer correctly for requests that
              are clear pending and treat the clear as successful.
Reproduction: Have I/O running on a device while multiple path events
              arrive in parallel.

Upstream-Description:

              s390/dasd: fix hanging device after clear subchannel

              When a device is in a status where CIO has killed all I/O by itself the
              interrupt for a clear request may not contain an irb to determine the
              clear function. Instead it contains an error pointer -EIO.
              This was ignored by the DASD int_handler leading to a hanging device
              waiting for a clear interrupt.

              Handle -EIO error pointer correctly for requests that are clear pending and
              treat the clear as successful.

              Signed-off-by: Stefan Haberland <sth@linux.vnet.ibm.com>
              Reviewed-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
              Cc: stable@vger.kernel.org
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Stefan Haberland <sth@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/block/dasd.c |   10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -1640,9 +1640,18 @@ void dasd_int_handler(struct ccw_device
 	unsigned long long now;
 	int expires;
 
+	cqr = (struct dasd_ccw_req *) intparm;
 	if (IS_ERR(irb)) {
 		switch (PTR_ERR(irb)) {
 		case -EIO:
+			if (cqr && cqr->status == DASD_CQR_CLEAR_PENDING) {
+				device = (struct dasd_device *) cqr->startdev;
+				cqr->status = DASD_CQR_CLEARED;
+				dasd_device_clear_timer(device);
+				wake_up(&dasd_flush_wq);
+				dasd_schedule_device_bh(device);
+				return;
+			}
 			break;
 		case -ETIMEDOUT:
 			DBF_EVENT_DEVID(DBF_WARNING, cdev, "%s: "
@@ -1658,7 +1667,6 @@ void dasd_int_handler(struct ccw_device
 	}
 
 	now = get_tod_clock();
-	cqr = (struct dasd_ccw_req *) intparm;
 	/* check for conditions that should be handled immediately */
 	if (!cqr ||
 	    !(scsw_dstat(&irb->scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &&
