From: Petr Mladek <pmladek@suse.cz>
Date: Thu, 15 May 2014 14:06:36 +0200
Subject: [RFC PATCH 04/11] printk: add NMI ring and cont buffers
Patch-mainline: Submitted https://lkml.org/lkml/2014/5/9/119
References: bnc#831949

pmladek@suse.cz:
There were needed some changes for SLE12 to do not break KABI:

+ the variables describing NMI log buffer has to be in the top level because
  the struct printk_log is not available
+ the related macros and helper functions are updated accordingly
+ the messages are not modified when the main log buffer is allocated;
  they might be parsed by some tool or so
+ ACCESS_ONCE has to be used in get_side_pos() functions, e.g. get_first_seq();
  otherwise, a compiler might generate speculative store operations and
  modify the global variables without the appropriate lock (bnc#879933)
+ function alloc_log_buf() uses memblock_alloc() instead of
  memblock_virt_alloc() to stay consistent with the original SLE12 code

Also there were added changes based on the patchset that added support
for automatic ring buffer size (bnc#835888):

+ allocation aligned to LOG_ALIGN
+ add units when printing the NMI log buffer size


This is another preparation patch for NMI safe printk implementation.
It adds a new ring and cont buffers to temporary store messages printed
from NMI context. They are used when the logbuf_lock for the main ring
buffer is already held.

Unfortunately, we need to store the index and the sequence number into
a single "unsigned log". I did not find any better way how to keep them
consistent. Both values are modified when new messages are added in
the NMI context. They are read when the messages are copied to the main
log buffer in the normal context. These two operations cannot be guarded
by a common lock because it would cause the original deadlock.

Anyway, this patch adds a bunch of macros that do the needed bit operations.
It also extends the existing "set/get" functions so that the access will
be transparent.

The ring buffer is allocated during early initialization such as log_buf.
It shares the same length for now but it will get improved in a later patch.

Also it updates messages that are printed when resizing the main ring buffer.
It makes them more explanatory and consistent with the message from the NMI
log buffer.

This patch does not change the existing behavior, except for the printed
messages. The logic for using the NMI buffer will be added in followup patches.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
---
 kernel/printk/printk.c |  132 +++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 112 insertions(+), 20 deletions(-)

--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -252,6 +252,7 @@ enum log_flags {
 /* define which log buffer need to be used in the given function */
 enum printk_log_type {
 	MAIN_LOG,
+	NMI_LOG,
 };
 
 struct printk_log {
@@ -299,6 +300,15 @@ static u32 log_first_idx;
 static u64 log_next_seq;
 static u32 log_next_idx;
 
+/*
+ * NMI log buffer is handled assynchronously. It is important to keep the index
+ * and sequence number in sync. We need to modify the values atomically and
+ * store both values in unsigned long. The following variables describe the
+ * first and next record stored in the NMI log buffer.
+ */
+static unsigned long nmi_log_first_id;
+static unsigned long nmi_log_next_id;
+
 /* the next printk record to write to the console */
 static u64 console_seq;
 static u32 console_idx;
@@ -328,19 +338,64 @@ static struct printk_cont main_cont = {
 	.buf = __main_cont_buf,
 };
 
+/*
+ * NMI ring buffer must be used if we are in NMI context and the lock for
+ * the main buffer is already in use by code that has been interrupted.
+ * The content of the NMI buffer is moved to the main buffer on the first
+ * occasion.
+ */
+static char __nmi_cont_buf[LOG_LINE_MAX];
+static char *nmi_log_buf;
+static u32 nmi_log_buf_len = __LOG_BUF_LEN;
+
+static struct printk_cont nmi_cont = {
+	.buf = __nmi_cont_buf,
+};
+
+/*
+ * Byte operations needed to manipulate index and sequence numbers for the NMI
+ * log buffer:
+ *	+ sequence number takes the lower half of the _id variable
+ *	+ index takes the higher half of the _id variable
+ */
+#define NMI_SEQ_BYTES (sizeof(nmi_log_first_id) * 8 / 2)
+#define NMI_IDX_BYTES NMI_SEQ_BYTES
+#define NMI_SEQ_MASK ((1UL << NMI_SEQ_BYTES) - 1)
+#define NMI_IDX_MASK (~NMI_SEQ_MASK)
+#define idx_from_id(id) ((id & NMI_IDX_MASK) >> NMI_SEQ_BYTES)
+#define seq_from_id(id) (id & NMI_SEQ_MASK)
+#define make_id(idx, seq) (((unsigned long)idx << NMI_SEQ_BYTES) | \
+			   (seq & NMI_SEQ_MASK))
+/*
+ * Maximum length of the allocated buffer. It has to be a power of two.
+ * It can be limited either by the maximum number of indexes or
+ * by the "buf_len" variable size.
+ */
+#define NMI_MAX_LEN_POWER (min(NMI_IDX_BYTES, sizeof(nmi_log_buf_len) * 8 - 1))
+#define NMI_MAX_LEN (1UL << NMI_MAX_LEN_POWER)
+
 static struct printk_cont *get_cont(enum printk_log_type log)
 {
-	return &main_cont;
+	if (log == MAIN_LOG)
+		return &main_cont;
+	else
+		return &nmi_cont;
 }
 
 static char *get_buf(enum printk_log_type log)
 {
-	return log_buf;
+	if (log == MAIN_LOG)
+		return log_buf;
+	else
+		return nmi_log_buf;
 }
 
 static u32 get_buf_len(enum printk_log_type log)
 {
-	return log_buf_len;
+	if (log == MAIN_LOG)
+		return log_buf_len;
+	else
+		return nmi_log_buf_len;
 }
 
 /*
@@ -348,11 +403,23 @@ static u32 get_buf_len(enum printk_log_t
  * for example, first_idx. Possible values are:
  *	+ side: "first", "next"
  *	+ pos: "idx", "seq"
+ *
+ * ACCESS_ONCE is needed to avoid speculative store operations, see bnc#879933.
+ * These functions are almost every time called under a lock and only the locked
+ * variables are accessed. Where the "nmi_log_*" variables are guarded by
+ * "nmi_logbuf_lock" and the "log_*" variables are guarded by "logbuf_lock".
+ *
+ * The only exception are functions merging messages from the NMI log buffer
+ * to the main log buffer, e.g. merge_nmi_delayed_printk(). There the
+ * "nmi_log_*" variables have to be accessed without the "nmi_logbuf_lock".
  */
 #define DEFINE_GET_POS(rettype, funcname, side, pos)		\
-static rettype funcname(const enum printk_log_type log)	\
+static rettype funcname(const enum printk_log_type log)		\
 {								\
-	return log_##side##_##pos;				\
+	if (log == MAIN_LOG)					\
+		return ACCESS_ONCE(log_##side##_##pos);		\
+	else							\
+		return pos##_from_id(ACCESS_ONCE(nmi_log_##side##_id)); \
 }
 
 DEFINE_GET_POS(u32, get_first_idx, first, idx)
@@ -360,7 +427,6 @@ DEFINE_GET_POS(u64, get_first_seq, first
 DEFINE_GET_POS(u32, get_next_idx, next, idx)
 DEFINE_GET_POS(u64, get_next_seq, next, seq)
 
-
 /*
  * Define functions needed to set the position values,
  * for example, first_idx. Possible values are:
@@ -369,8 +435,12 @@ DEFINE_GET_POS(u64, get_next_seq, next,
 #define DEFINE_SET_POS(funcname, side)					\
 static void funcname(enum printk_log_type log, u32 idx, u64 seq)	\
 {									\
-	log_##side##_idx = idx;					\
-	log_##side##_seq = seq;				\
+	if (log == MAIN_LOG) {						\
+		log_##side##_idx = idx;					\
+		log_##side##_seq = seq;					\
+	} else {							\
+		nmi_log_##side##_id = make_id(idx, seq);		\
+	}								\
 }
 
 DEFINE_SET_POS(set_first_pos, first)
@@ -436,7 +506,10 @@ static u32 inc_idx(enum printk_log_type
 /* get next sequence number for the given one */
 static u64 inc_seq(enum printk_log_type log, u64 seq)
 {
-	return ++seq;
+	if (log == MAIN_LOG)
+		return ++seq;
+	else
+		return ++seq & NMI_SEQ_MASK;
 }
 
 /*
@@ -1026,12 +1099,41 @@ static void __init log_buf_add_cpu(void)
 	log_buf_len_update(cpu_extra + __LOG_BUF_LEN);
 }
 
+char * __init alloc_log_buf(int early, unsigned len)
+{
+	if (early) {
+		unsigned long mem;
+
+		mem = memblock_alloc(len, LOG_ALIGN);
+		if (!mem)
+			return 0;
+		return __va(mem);
+	}
+
+	return alloc_bootmem_nopanic(len);
+}
+
 void __init setup_log_buf(int early)
 {
 	unsigned long flags;
 	char *new_log_buf;
 	int free;
 
+	if (!nmi_log_buf) {
+		/* use the same size that will be used for normal buffer */
+		if (new_log_buf_len > nmi_log_buf_len)
+			nmi_log_buf_len = new_log_buf_len;
+		if (nmi_log_buf_len > NMI_MAX_LEN)
+			nmi_log_buf_len = NMI_MAX_LEN;
+		nmi_log_buf = alloc_log_buf(early, nmi_log_buf_len);
+		if (!nmi_log_buf)
+			pr_err("%d bytes not available for NMI ring buffer\n",
+			       nmi_log_buf_len);
+		else
+			pr_info("NMI ring buffer size: %d bytes\n",
+				nmi_log_buf_len);
+	}
+
 	if (log_buf != __log_buf)
 		return;
 
@@ -1041,17 +1143,7 @@ void __init setup_log_buf(int early)
 	if (!new_log_buf_len)
 		return;
 
-	if (early) {
-		unsigned long mem;
-
-		mem = memblock_alloc(new_log_buf_len, LOG_ALIGN);
-		if (!mem)
-			return;
-		new_log_buf = __va(mem);
-	} else {
-		new_log_buf = alloc_bootmem_nopanic(new_log_buf_len);
-	}
-
+	new_log_buf = alloc_log_buf(early, new_log_buf_len);
 	if (unlikely(!new_log_buf)) {
 		pr_err("log_buf_len: %ld bytes not available\n",
 			new_log_buf_len);
