From: NeilBrown <neilb@suse.de>
Subject: NFS: make nfs_flush_incompatible more generous
Patch-mainline: not wanted
References: bnc#816099

If two processes open the same NFS file and write to it, then they are
currently considered to be separate clients and when one writes, all
changes from the other are flushed first.

This affect memory mapping as well, so if the file is mmaps using two
separate opens, then an update from one will flush all changes from
the other.

This can be a serious performance problem.

So change the tests so that if different credentials or different
locks are involved we still flush, but simple accesses by the same
user do not cause flushes.

Upstrea (Trond) currently doesn't like this because it means that
errors can end up going back to the "wrong" application.  I think this
is a fairly meaningless concern.

Signed-off-by: Neil Brown <neilb@suse.de>

---
 fs/nfs/write.c |   12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -862,11 +862,21 @@ int nfs_flush_incompatible(struct file *
 		if (req == NULL)
 			return 0;
 		l_ctx = req->wb_lock_context;
-		do_flush = req->wb_page != page || req->wb_context != ctx;
+		do_flush = req->wb_page != page;
 		if (l_ctx && ctx->dentry->d_inode->i_flock != NULL) {
 			do_flush |= l_ctx->lockowner.l_owner != current->files
 				|| l_ctx->lockowner.l_pid != current->tgid;
 		}
+		if (req->wb_context != ctx) {
+			do_flush |=
+				(req->wb_context->dentry != ctx->dentry ||
+				 req->wb_context->cred != ctx->cred );
+			if (req->wb_context->state || ctx->state)
+				do_flush |=
+					(req->wb_lock_context->lockowner.l_owner != current->files ||
+					 req->wb_lock_context->lockowner.l_pid != current->tgid);
+		}
+
 		nfs_release_request(req);
 		if (!do_flush)
 			return 0;
