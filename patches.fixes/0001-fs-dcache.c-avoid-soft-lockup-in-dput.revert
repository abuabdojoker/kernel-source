From: Wei Fang <fangwei1@huawei.com>
Date: Wed, 6 Jul 2016 11:32:20 +0800
Subject: REVERT [PATCH] fs/dcache.c: avoid soft-lockup in dput()
Patch-mainline: Never, this is a revert of a -stable backport
References: bsc#997639

This REVERTS the patch described below.
Where it says "should be safe", it isn't because autofs does
call dput() under a spinlock.  The fix for autofs is much
more intrusive than just reverting this change, so the revert is safer.

The situation that is patch addresses only occurs when lots of threads
close the same file at the same time.  This is only likely to happen in
stress tests, so it is extremely unlikely for customers to be affected.
The reverted bahaviour is identical to that in SLE12-SP1, so there will
certainly not be a regresson.
 - NeilBrown


We triggered soft-lockup under stress test which
open/access/write/close one file concurrently on more than
five different CPUs:

Warn: soft lockup - CPU#0 stuck for 11s! [who:30631]
...
[<ffffffc0003986f8>] dput+0x100/0x298
[<ffffffc00038c2dc>] terminate_walk+0x4c/0x60
[<ffffffc00038f56c>] path_lookupat+0x5cc/0x7a8
[<ffffffc00038f780>] filename_lookup+0x38/0xf0
[<ffffffc000391180>] user_path_at_empty+0x78/0xd0
[<ffffffc0003911f4>] user_path_at+0x1c/0x28
[<ffffffc00037d4fc>] SyS_faccessat+0xb4/0x230

->d_lock trylock may failed many times because of concurrently
operations, and dput() may execute a long time.

Fix this by replacing cpu_relax() with cond_resched().
dput() used to be sleepable, so make it sleepable again
should be safe.

Cc: <stable@vger.kernel.org>
Signed-off-by: Wei Fang <fangwei1@huawei.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Acked-by: NeilBrown <neilb@suse.com>

---
 fs/dcache.c |    7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -584,6 +584,7 @@ static struct dentry *dentry_kill(struct
 
 failed:
 	spin_unlock(&dentry->d_lock);
+	cpu_relax();
 	return dentry; /* try again with same dentry */
 }
 
@@ -757,8 +758,6 @@ void dput(struct dentry *dentry)
 		return;
 
 repeat:
-	might_sleep();
-
 	rcu_read_lock();
 	if (likely(fast_dput(dentry))) {
 		rcu_read_unlock();
@@ -790,10 +789,8 @@ repeat:
 
 kill_it:
 	dentry = dentry_kill(dentry);
-	if (dentry) {
-		cond_resched();
+	if (dentry)
 		goto repeat;
-	}
 }
 EXPORT_SYMBOL(dput);
 
