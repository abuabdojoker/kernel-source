From: Petr Mladek <pmladek@suse.cz>
Date: Tue, 6 May 2014 14:30:35 +0200
Subject: [RFC PATCH 02/11] printk: allow to handle more log buffers
Patch-mainline: Submitted https://lkml.org/lkml/2014/5/9/124
References: bnc#831949

pmladek@suse.cz:
This patch needed some modifications for SLED12 to avoid KABI changes:

+ struct printk_log is not renamed to printk_msg
+ new struct printk_log is not created; the variables are kept in top level
+ enum printk_log_type is introduced to be passed as a parameter instead
  of the pointer to the struct; hence we pass MAIN_LOG instead of &main_log
+ get_cont(), get_buf(), get_buf_len() helper functions are created to get the
  right value
+ get_first_idx() and other new helpers are not used in syslog-, console-,
  and kmsg-related functions to reduce the size of the patch and potential
  conflicts with other patches; these are the functions where &main_log was
  passed


This is another preparation patch for NMI safe printk implementation. An extra
log buffer will be used in NMI context when the lock for the main ring buffer
is already taken. It is not possible to wait for the main lock because it can
cause a deadlock.

This patch creates struct "printk_log" and put there all variables that are
needed to handle the log buffer, including pointer to the "cont" buffer.
This is why it renames "struct cont" to "struct printk_cont" and moves the
declaration to the top.

Unfortunately, index and sequence values will need to be modified without a lock
when the NMI log buffer will be merged back to the main log buffer. The only
safe solution is to atomically read and write both, the index and the sequence
number. It means that both values need to fit "unsigned long".

Using "unsigned long" for both "idx" and "seq" is fine for the temporary NMI
log buffer but it would limit the main log buffer too much, especially on
32-bit architectures. Therefore, we put these values into the separate
"struct printk_main_log_pos" and put it into "struct printk_log" via
an union.

The global buffers are declared as "main_cont" and "main_log". Then they
will be clearly distinguished from the NMI variant.

The patch also introduces several helper function to make it easier to access
the "idx" and "seq" values. Note that they will be more complicated once we
introduce the NMI log buffer where both values need to be updated atomically.

In addition, the function log_next() is renamed to inc_idx(). The intention
is to make it consistent with the new inc_seq(). Note that the "next_" prefix
could not be used because "next_idx" and "next_seq" is already used to mark
the last message in the ring buffer.

The followup patches will add "nmi_log" and "nmi_cont" that will be used to
temporary store messages printed in the NMI context. They will be merged into
the main log buffer when the "logbuf_lock" is available.

The functions working with console, syslog, and kmsg will work only with the
main ring buffer, so we could hardcode it there. Only the functions, that are
used to store the information into the ring buffer, will work with the selected
ring buffer and we need to pass it as a parameter.

IMPORTANT: This change causes problems for the external tools that are accessing
the structures, e.g. crash, makedumpfile. They need to get updated.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
---
 kernel/printk/printk.c |  353 +++++++++++++++++++++++++++++++------------------
 1 file changed, 229 insertions(+), 124 deletions(-)

--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -169,6 +169,13 @@ EXPORT_SYMBOL(console_set_on_cmdline);
 static int console_may_schedule;
 
 /*
+ * The logbuf_lock protects kmsg buffer, indexes, counters. This can be taken
+ * within the scheduler's rq lock. It must be released before calling
+ * console_unlock() or anything else that might wake up a process.
+ */
+static DEFINE_RAW_SPINLOCK(logbuf_lock);
+
+/*
  * The printk log buffer consists of a chain of concatenated variable
  * length records. Every record starts with a record header, containing
  * the overall length of the record.
@@ -242,6 +249,11 @@ enum log_flags {
 	LOG_CONT	= 8,	/* text is a fragment of a continuation line */
 };
 
+/* define which log buffer need to be used in the given function */
+enum printk_log_type {
+	MAIN_LOG,
+};
+
 struct printk_log {
 	u64 ts_nsec;		/* timestamp in nanoseconds */
 	u16 len;		/* length of entire record */
@@ -252,15 +264,27 @@ struct printk_log {
 	u8 level:3;		/* syslog level */
 };
 
+#ifdef CONFIG_PRINTK
 /*
- * The logbuf_lock protects kmsg buffer, indices, counters.  This can be taken
- * within the scheduler's rq lock. It must be released before calling
- * console_unlock() or anything else that might wake up a process.
+ * Continuation lines are buffered, and not committed to the record buffer
+ * until the line is complete, or a race forces it. The line fragments
+ * though, are printed immediately to the consoles to ensure everything has
+ * reached the console in case of a kernel crash.
  */
-static DEFINE_RAW_SPINLOCK(logbuf_lock);
+struct printk_cont {
+	char *buf;
+	size_t len;			/* length == 0 means unused buffer */
+	size_t cons;			/* bytes written to console */
+	struct task_struct *owner;	/* task of first print*/
+	u64 ts_nsec;			/* time of first print */
+	u8 level;			/* log level of first message */
+	u8 facility;			/* log level of first message */
+	enum log_flags flags;		/* prefix, newline flags */
+	bool flushed:1;			/* buffer sealed and committed */
+};
 
-#ifdef CONFIG_PRINTK
 DECLARE_WAIT_QUEUE_HEAD(log_wait);
+
 /* the next printk record to read by syslog(READ) or /proc/kmsg */
 static u64 syslog_seq;
 static u32 syslog_idx;
@@ -296,9 +320,62 @@ static u32 clear_idx;
 #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
 #define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)
 static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
+static char __main_cont_buf[LOG_LINE_MAX];
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
 
+static struct printk_cont main_cont = {
+	.buf = __main_cont_buf,
+};
+
+static struct printk_cont *get_cont(enum printk_log_type log)
+{
+	return &main_cont;
+}
+
+static char *get_buf(enum printk_log_type log)
+{
+	return log_buf;
+}
+
+static u32 get_buf_len(enum printk_log_type log)
+{
+	return log_buf_len;
+}
+
+/*
+ * Define functions needed to get the position values,
+ * for example, first_idx. Possible values are:
+ *	+ side: "first", "next"
+ *	+ pos: "idx", "seq"
+ */
+#define DEFINE_GET_POS(rettype, funcname, side, pos)		\
+static rettype funcname(const enum printk_log_type log)	\
+{								\
+	return log_##side##_##pos;				\
+}
+
+DEFINE_GET_POS(u32, get_first_idx, first, idx)
+DEFINE_GET_POS(u64, get_first_seq, first, seq)
+DEFINE_GET_POS(u32, get_next_idx, next, idx)
+DEFINE_GET_POS(u64, get_next_seq, next, seq)
+
+
+/*
+ * Define functions needed to set the position values,
+ * for example, first_idx. Possible values are:
+ *	+ side: "first", "next"
+ */
+#define DEFINE_SET_POS(funcname, side)					\
+static void funcname(enum printk_log_type log, u32 idx, u64 seq)	\
+{									\
+	log_##side##_idx = idx;					\
+	log_##side##_seq = seq;				\
+}
+
+DEFINE_SET_POS(set_first_pos, first)
+DEFINE_SET_POS(set_next_pos, next)
+
 /*
  * How many characters can we print in one call of printk before asking
  * other cpus to continue printing. 0 means infinity. Tunable via
@@ -325,23 +402,23 @@ static char *log_dict(const struct print
 }
 
 /* get record by index; idx must point to valid msg */
-static struct printk_log *log_from_idx(u32 idx)
+static struct printk_log *log_from_idx(enum printk_log_type log, u32 idx)
 {
-	struct printk_log *msg = (struct printk_log *)(log_buf + idx);
+	struct printk_log *msg = (struct printk_log *)(get_buf(log) + idx);
 
 	/*
 	 * A length == 0 record is the end of buffer marker. Wrap around and
 	 * read the message at the start of the buffer.
 	 */
 	if (!msg->len)
-		return (struct printk_log *)log_buf;
+		return (struct printk_log *)get_buf(log);
 	return msg;
 }
 
 /* get next record; idx must point to valid msg */
-static u32 log_next(u32 idx)
+static u32 inc_idx(enum printk_log_type log, u32 idx)
 {
-	struct printk_log *msg = (struct printk_log *)(log_buf + idx);
+	struct printk_log *msg = (struct printk_log *)(get_buf(log) + idx);
 
 	/* length == 0 indicates the end of the buffer; wrap */
 	/*
@@ -350,12 +427,41 @@ static u32 log_next(u32 idx)
 	 * return the one after that.
 	 */
 	if (!msg->len) {
-		msg = (struct printk_log *)log_buf;
+		msg = (struct printk_log *)get_buf(log);
 		return msg->len;
 	}
 	return idx + msg->len;
 }
 
+/* get next sequence number for the given one */
+static u64 inc_seq(enum printk_log_type log, u64 seq)
+{
+	return ++seq;
+}
+
+/*
+ * Define helper functions to move the position to the next message
+ * a safe way. Possible values are:
+ *	+ side: "first", "next"
+ */
+#define GENERATE_INC_POS(funcname, side)	\
+static void funcname(enum printk_log_type log)	\
+{						\
+	u32 idx;				\
+	u64 seq;				\
+						\
+	idx = get_##side##_idx(log);		\
+	seq = get_##side##_seq(log);		\
+						\
+	idx = inc_idx(log, idx);		\
+	seq = inc_seq(log, seq);		\
+						\
+	set_##side##_pos(log, idx, seq);	\
+}
+
+GENERATE_INC_POS(inc_first_pos, first)
+GENERATE_INC_POS(inc_next_pos, next)
+
 /*
  * Check whether there is enough free space for the given message.
  *
@@ -365,14 +471,15 @@ static u32 log_next(u32 idx)
  * If the buffer is empty, we must respect the position of the indexes.
  * They cannot be reset to the beginning of the buffer.
  */
-static int logbuf_has_space(u32 msg_size, bool empty)
+static int logbuf_has_space(enum printk_log_type log, u32 msg_size, bool empty)
 {
 	u32 free;
 
-	if (log_next_idx > log_first_idx || empty)
-		free = max(log_buf_len - log_next_idx, log_first_idx);
+	if (get_next_idx(log) > get_first_idx(log) || empty)
+		free = max(get_buf_len(log) - get_next_idx(log),
+			   get_first_idx(log));
 	else
-		free = log_first_idx - log_next_idx;
+		free = get_first_idx(log) - get_next_idx(log);
 
 	/*
 	 * We need space also for an empty header that signalizes wrapping
@@ -381,18 +488,17 @@ static int logbuf_has_space(u32 msg_size
 	return free >= msg_size + sizeof(struct printk_log);
 }
 
-static int log_make_free_space(u32 msg_size)
+static int log_make_free_space(enum printk_log_type log, u32 msg_size)
 {
-	while (log_first_seq < log_next_seq) {
-		if (logbuf_has_space(msg_size, false))
+	while (get_first_seq(log) < get_next_seq(log)) {
+		if (logbuf_has_space(log, msg_size, false))
 			return 0;
 		/* drop old messages until we have enough continuous space */
-		log_first_idx = log_next(log_first_idx);
-		log_first_seq++;
+		inc_first_pos(log);
 	}
 
 	/* sequence numbers are equal, so the log buffer is empty */
-	if (logbuf_has_space(msg_size, true))
+	if (logbuf_has_space(log, msg_size, true))
 		return 0;
 
 	return -ENOMEM;
@@ -418,14 +524,15 @@ static u32 msg_used_size(u16 text_len, u
 #define MAX_LOG_TAKE_PART 4
 static const char trunc_msg[] = "<truncated>";
 
-static u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,
+static u32 truncate_msg(enum printk_log_type log,
+			u16 *text_len, u16 *trunc_msg_len,
 			u16 *dict_len, u32 *pad_len)
 {
 	/*
 	 * The message should not take the whole buffer. Otherwise, it might
 	 * get removed too soon.
 	 */
-	u32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;
+	u32 max_text_len = get_buf_len(log) / MAX_LOG_TAKE_PART;
 	if (*text_len > max_text_len)
 		*text_len = max_text_len;
 	/* enable the warning message */
@@ -437,7 +544,7 @@ static u32 truncate_msg(u16 *text_len, u
 }
 
 /* insert record into the buffer, discard old ones, update heads */
-static int log_store(int facility, int level,
+static int log_store(enum printk_log_type log, int facility, int level,
 		     enum log_flags flags, u64 ts_nsec,
 		     const char *dict, u16 dict_len,
 		     const char *text, u16 text_len)
@@ -449,27 +556,29 @@ static int log_store(int facility, int l
 	/* number of '\0' padding bytes to next message */
 	size = msg_used_size(text_len, dict_len, &pad_len);
 
-	if (log_make_free_space(size)) {
+	if (log_make_free_space(log, size)) {
 		/* truncate the message if it is too long for empty buffer */
-		size = truncate_msg(&text_len, &trunc_msg_len,
+		size = truncate_msg(log, &text_len, &trunc_msg_len,
 				    &dict_len, &pad_len);
 		/* survive when the log buffer is too small for trunc_msg */
-		if (log_make_free_space(size))
+		if (log_make_free_space(log, size))
 			return 0;
 	}
 
-	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
+	if (get_next_idx(log) + size + sizeof(struct printk_log) >
+	    get_buf_len(log)) {
 		/*
 		 * This message + an additional empty header does not fit
 		 * at the end of the buffer. Add an empty header with len == 0
 		 * to signify a wrap around.
 		 */
-		memset(log_buf + log_next_idx, 0, sizeof(struct printk_log));
-		log_next_idx = 0;
+		memset(get_buf(log) + get_next_idx(log), 0,
+		       sizeof(struct printk_log));
+		set_next_pos(log, 0, get_next_seq(log));
 	}
 
 	/* fill message */
-	msg = (struct printk_log *)(log_buf + log_next_idx);
+	msg = (struct printk_log *)(get_buf(log) + get_next_idx(log));
 	memcpy(log_text(msg), text, text_len);
 	msg->text_len = text_len;
 	if (trunc_msg_len) {
@@ -489,8 +598,7 @@ static int log_store(int facility, int l
 	msg->len = size;
 
 	/* insert message */
-	log_next_idx += msg->len;
-	log_next_seq++;
+	inc_next_pos(log);
 
 	return msg->text_len;
 }
@@ -650,7 +758,7 @@ static ssize_t devkmsg_read(struct file
 		goto out;
 	}
 
-	msg = log_from_idx(user->idx);
+	msg = log_from_idx(MAIN_LOG, user->idx);
 	ts_usec = msg->ts_nsec;
 	do_div(ts_usec, 1000);
 
@@ -711,7 +819,7 @@ static ssize_t devkmsg_read(struct file
 		user->buf[len++] = '\n';
 	}
 
-	user->idx = log_next(user->idx);
+	user->idx = inc_idx(MAIN_LOG, user->idx);
 	user->seq++;
 	raw_spin_unlock_irq(&logbuf_lock);
 
@@ -1166,12 +1274,12 @@ static int syslog_print(char __user *buf
 		}
 
 		skip = syslog_partial;
-		msg = log_from_idx(syslog_idx);
+		msg = log_from_idx(MAIN_LOG, syslog_idx);
 		n = msg_print_text(msg, syslog_prev, true, text,
 				   LOG_LINE_MAX + PREFIX_MAX);
 		if (n - syslog_partial <= size) {
 			/* message fits into buffer, move forward */
-			syslog_idx = log_next(syslog_idx);
+			syslog_idx = inc_idx(MAIN_LOG, syslog_idx);
 			syslog_seq++;
 			syslog_prev = msg->flags;
 			n -= syslog_partial;
@@ -1232,11 +1340,11 @@ static int syslog_print_all(char __user
 		idx = clear_idx;
 		prev = 0;
 		while (seq < log_next_seq) {
-			struct printk_log *msg = log_from_idx(idx);
+			struct printk_log *msg = log_from_idx(MAIN_LOG, idx);
 
 			len += msg_print_text(msg, prev, true, NULL, 0);
 			prev = msg->flags;
-			idx = log_next(idx);
+			idx = inc_idx(MAIN_LOG, idx);
 			seq++;
 		}
 
@@ -1245,11 +1353,11 @@ static int syslog_print_all(char __user
 		idx = clear_idx;
 		prev = 0;
 		while (len > size && seq < log_next_seq) {
-			struct printk_log *msg = log_from_idx(idx);
+			struct printk_log *msg = log_from_idx(MAIN_LOG, idx);
 
 			len -= msg_print_text(msg, prev, true, NULL, 0);
 			prev = msg->flags;
-			idx = log_next(idx);
+			idx = inc_idx(MAIN_LOG, idx);
 			seq++;
 		}
 
@@ -1258,7 +1366,7 @@ static int syslog_print_all(char __user
 
 		len = 0;
 		while (len >= 0 && seq < next_seq) {
-			struct printk_log *msg = log_from_idx(idx);
+			struct printk_log *msg = log_from_idx(MAIN_LOG, idx);
 			int textlen;
 
 			textlen = msg_print_text(msg, prev, true, text,
@@ -1267,7 +1375,7 @@ static int syslog_print_all(char __user
 				len = textlen;
 				break;
 			}
-			idx = log_next(idx);
+			idx = inc_idx(MAIN_LOG, idx);
 			seq++;
 			prev = msg->flags;
 
@@ -1400,10 +1508,10 @@ int do_syslog(int type, char __user *buf
 
 			error = 0;
 			while (seq < log_next_seq) {
-				struct printk_log *msg = log_from_idx(idx);
+				struct printk_log *msg = log_from_idx(MAIN_LOG, idx);
 
 				error += msg_print_text(msg, prev, true, NULL, 0);
-				idx = log_next(idx);
+				idx = inc_idx(MAIN_LOG, idx);
 				seq++;
 				prev = msg->flags;
 			}
@@ -1543,106 +1651,98 @@ static inline void printk_delay(void)
 	}
 }
 
-/*
- * Continuation lines are buffered, and not committed to the record buffer
- * until the line is complete, or a race forces it. The line fragments
- * though, are printed immediately to the consoles to ensure everything has
- * reached the console in case of a kernel crash.
- */
-static struct cont {
-	char buf[LOG_LINE_MAX];
-	size_t len;			/* length == 0 means unused buffer */
-	size_t cons;			/* bytes written to console */
-	struct task_struct *owner;	/* task of first print*/
-	u64 ts_nsec;			/* time of first print */
-	u8 level;			/* log level of first message */
-	u8 facility;			/* log level of first message */
-	enum log_flags flags;		/* prefix, newline flags */
-	bool flushed:1;			/* buffer sealed and committed */
-} cont;
-
-static void cont_flush(enum log_flags flags)
+static void cont_flush(enum printk_log_type log, enum log_flags flags)
 {
-	if (cont.flushed)
+	struct printk_cont *cont = get_cont(log);
+
+	if (cont->flushed)
 		return;
-	if (cont.len == 0)
+	if (cont->len == 0)
 		return;
 
-	if (cont.cons) {
+	if (cont->cons) {
 		/*
 		 * If a fragment of this line was directly flushed to the
 		 * console; wait for the console to pick up the rest of the
 		 * line. LOG_NOCONS suppresses a duplicated output.
 		 */
-		log_store(cont.facility, cont.level, flags | LOG_NOCONS,
-			  cont.ts_nsec, NULL, 0, cont.buf, cont.len);
-		cont.flags = flags;
-		cont.flushed = true;
+		log_store(log, cont->facility, cont->level, flags | LOG_NOCONS,
+			  cont->ts_nsec, NULL, 0, cont->buf, cont->len);
+		cont->flags = flags;
+		cont->flushed = true;
 	} else {
 		/*
 		 * If no fragment of this line ever reached the console,
 		 * just submit it to the store and free the buffer.
 		 */
-		log_store(cont.facility, cont.level, flags, 0,
-			  NULL, 0, cont.buf, cont.len);
-		cont.len = 0;
+		log_store(log, cont->facility, cont->level, flags, 0,
+			  NULL, 0, cont->buf, cont->len);
+		cont->len = 0;
 	}
 }
 
-static bool cont_add(int facility, int level, const char *text, size_t len)
+static bool cont_add(enum printk_log_type log, int facility, int level,
+		     const char *text, size_t len)
 {
-	if (cont.len && cont.flushed)
+	struct printk_cont *cont = get_cont(log);
+
+	if (cont->len && cont->flushed)
 		return false;
 
-	if (cont.len + len > sizeof(cont.buf)) {
+	if (cont->len + len > sizeof(cont->buf)) {
 		/* the line gets too long, split it up in separate records */
-		cont_flush(LOG_CONT);
+		cont_flush(log, LOG_CONT);
 		return false;
 	}
 
-	if (!cont.len) {
-		cont.facility = facility;
-		cont.level = level;
-		cont.owner = current;
-		cont.ts_nsec = local_clock();
-		cont.flags = 0;
-		cont.cons = 0;
-		cont.flushed = false;
+	if (!cont->len) {
+		cont->facility = facility;
+		cont->level = level;
+		cont->owner = current;
+		cont->ts_nsec = local_clock();
+		cont->flags = 0;
+		cont->cons = 0;
+		cont->flushed = false;
 	}
 
-	memcpy(cont.buf + cont.len, text, len);
-	cont.len += len;
+	memcpy(cont->buf + cont->len, text, len);
+	cont->len += len;
 
-	if (cont.len > (sizeof(cont.buf) * 80) / 100)
-		cont_flush(LOG_CONT);
+	if (cont->len > (sizeof(cont->buf) * 80) / 100)
+		cont_flush(log, LOG_CONT);
 
 	return true;
 }
 
+/*
+ * Only messages from the main log buffer are printed directly to
+ * the console. Therefore this function operates directly with the main
+ * continuous buffer.
+ */
 static size_t cont_print_text(char *text, size_t size)
 {
 	size_t textlen = 0;
 	size_t len;
 
-	if (cont.cons == 0 && (console_prev & LOG_NEWLINE)) {
-		textlen += print_time(cont.ts_nsec, text);
+	if (main_cont.cons == 0 && (console_prev & LOG_NEWLINE)) {
+		textlen += print_time(main_cont.ts_nsec, text);
 		size -= textlen;
 	}
 
-	len = cont.len - cont.cons;
+	len = main_cont.len - main_cont.cons;
 	if (len > 0) {
 		if (len+1 > size)
 			len = size-1;
-		memcpy(text + textlen, cont.buf + cont.cons, len);
+		memcpy(text + textlen, main_cont.buf + main_cont.cons, len);
 		textlen += len;
-		cont.cons = cont.len;
+		main_cont.cons = main_cont.len;
 	}
 
-	if (cont.flushed) {
-		if (cont.flags & LOG_NEWLINE)
+	if (main_cont.flushed) {
+		if (main_cont.flags & LOG_NEWLINE)
 			text[textlen++] = '\n';
 		/* got everything, release buffer */
-		cont.len = 0;
+		main_cont.len = 0;
 	}
 	return textlen;
 }
@@ -1651,6 +1751,8 @@ asmlinkage int vprintk_emit(int facility
 			    const char *dict, size_t dictlen,
 			    const char *fmt, va_list args)
 {
+	enum printk_log_type log = MAIN_LOG;
+	struct printk_cont *cont = &main_cont;
 	static int recursion_bug;
 	static char textbuf[LOG_LINE_MAX];
 	char *text = textbuf;
@@ -1705,7 +1807,7 @@ asmlinkage int vprintk_emit(int facility
 		recursion_bug = 0;
 		text_len = strlen(recursion_msg);
 		/* emit KERN_CRIT message */
-		printed_len += log_store(0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
+		printed_len += log_store(log, 0, 2, LOG_PREFIX|LOG_NEWLINE, 0,
 					 NULL, 0, recursion_msg, text_len);
 	}
 
@@ -1757,14 +1859,15 @@ asmlinkage int vprintk_emit(int facility
 		 * Flush the conflicting buffer. An earlier newline was missing,
 		 * or another task also prints continuation lines.
 		 */
-		if (cont.len && (lflags & LOG_PREFIX || cont.owner != current))
-			cont_flush(LOG_NEWLINE);
+		if (cont->len &&
+		    (lflags & LOG_PREFIX || cont->owner != current))
+			cont_flush(log, LOG_NEWLINE);
 
 		/* buffer line if possible, otherwise store it right away */
-		if (cont_add(facility, level, text, text_len))
+		if (cont_add(log, facility, level, text, text_len))
 			printed_len += text_len;
 		else
-			printed_len += log_store(facility, level,
+			printed_len += log_store(log, facility, level,
 						 lflags | LOG_CONT, 0,
 						 dict, dictlen, text, text_len);
 	} else {
@@ -1778,18 +1881,19 @@ asmlinkage int vprintk_emit(int facility
 		 * If the preceding printk was from a different task and missed
 		 * a newline, flush and append the newline.
 		 */
-		if (cont.len) {
-			if (cont.owner == current && !(lflags & LOG_PREFIX))
-				stored = cont_add(facility, level, text,
+		if (cont->len) {
+			if (cont->owner == current && !(lflags & LOG_PREFIX))
+				stored = cont_add(log, facility, level, text,
 						  text_len);
-			cont_flush(LOG_NEWLINE);
+			cont_flush(log, LOG_NEWLINE);
 		}
 
 		if (stored)
 			printed_len += text_len;
 		else
-			printed_len += log_store(facility, level, lflags, 0,
-						 dict, dictlen, text, text_len);
+			printed_len += log_store(log, facility, level, lflags,
+						 0, dict, dictlen,
+						 text, text_len);
 	}
 
 	logbuf_cpu = UINT_MAX;
@@ -1906,7 +2010,7 @@ static struct cont {
 	bool flushed:1;
 } cont;
 static struct printk_log *log_from_idx(u32 idx) { return NULL; }
-static u32 log_next(u32 idx) { return 0; }
+static u32 inc_idx(enum printk_log_type log, u32 idx) { return 0; }
 static void call_console_drivers(int level, const char *text, size_t len) {}
 static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,
 			     bool syslog, char *buf, size_t size) { return 0; }
@@ -2158,6 +2262,7 @@ int is_console_locked(void)
 	return console_locked;
 }
 
+/* only messages from the main cont buffer are flushed directly */
 static void console_cont_flush(char *text, size_t size)
 {
 	unsigned long flags;
@@ -2165,7 +2270,7 @@ static void console_cont_flush(char *tex
 
 	raw_spin_lock_irqsave(&logbuf_lock, flags);
 
-	if (!cont.len)
+	if (!main_cont.len)
 		goto out;
 
 	/*
@@ -2173,13 +2278,13 @@ static void console_cont_flush(char *tex
 	 * busy. The earlier ones need to be printed before this one, we
 	 * did not flush any fragment so far, so just let it queue up.
 	 */
-	if (console_seq < log_next_seq && !cont.cons)
+	if (console_seq < log_next_seq && !main_cont.cons)
 		goto out;
 
 	len = cont_print_text(text, size);
 	raw_spin_unlock(&logbuf_lock);
 	stop_critical_timings();
-	call_console_drivers(cont.level, text, len);
+	call_console_drivers(main_cont.level, text, len);
 	start_critical_timings();
 	local_irq_restore(flags);
 	return;
@@ -2278,13 +2383,13 @@ skip:
 			break;
 		}
 
-		msg = log_from_idx(console_idx);
+		msg = log_from_idx(MAIN_LOG, console_idx);
 		if (msg->flags & LOG_NOCONS) {
 			/*
 			 * Skip record we have buffered and already printed
 			 * directly to the console when we received it.
 			 */
-			console_idx = log_next(console_idx);
+			console_idx = inc_idx(MAIN_LOG, console_idx);
 			console_seq++;
 			/*
 			 * We will get here again when we register a new
@@ -2299,7 +2404,7 @@ skip:
 		level = msg->level;
 		len = msg_print_text(msg, console_prev, false,
 				     text, sizeof(text));
-		console_idx = log_next(console_idx);
+		console_idx = inc_idx(MAIN_LOG, console_idx);
 		console_seq++;
 		console_prev = msg->flags;
 		raw_spin_unlock(&logbuf_lock);
@@ -2955,10 +3060,10 @@ bool kmsg_dump_get_line_nolock(struct km
 	if (dumper->cur_seq >= log_next_seq)
 		goto out;
 
-	msg = log_from_idx(dumper->cur_idx);
+	msg = log_from_idx(MAIN_LOG, dumper->cur_idx);
 	l = msg_print_text(msg, 0, syslog, line, size);
 
-	dumper->cur_idx = log_next(dumper->cur_idx);
+	dumper->cur_idx = inc_idx(MAIN_LOG, dumper->cur_idx);
 	dumper->cur_seq++;
 	ret = true;
 out:
@@ -3050,10 +3155,10 @@ bool kmsg_dump_get_buffer(struct kmsg_du
 	idx = dumper->cur_idx;
 	prev = 0;
 	while (seq < dumper->next_seq) {
-		struct printk_log *msg = log_from_idx(idx);
+		struct printk_log *msg = log_from_idx(MAIN_LOG, idx);
 
 		l += msg_print_text(msg, prev, true, NULL, 0);
-		idx = log_next(idx);
+		idx = inc_idx(MAIN_LOG, idx);
 		seq++;
 		prev = msg->flags;
 	}
@@ -3063,10 +3168,10 @@ bool kmsg_dump_get_buffer(struct kmsg_du
 	idx = dumper->cur_idx;
 	prev = 0;
 	while (l > size && seq < dumper->next_seq) {
-		struct printk_log *msg = log_from_idx(idx);
+		struct printk_log *msg = log_from_idx(MAIN_LOG, idx);
 
 		l -= msg_print_text(msg, prev, true, NULL, 0);
-		idx = log_next(idx);
+		idx = inc_idx(MAIN_LOG, idx);
 		seq++;
 		prev = msg->flags;
 	}
@@ -3077,10 +3182,10 @@ bool kmsg_dump_get_buffer(struct kmsg_du
 
 	l = 0;
 	while (seq < dumper->next_seq) {
-		struct printk_log *msg = log_from_idx(idx);
+		struct printk_log *msg = log_from_idx(MAIN_LOG, idx);
 
 		l += msg_print_text(msg, prev, syslog, buf + l, size - l);
-		idx = log_next(idx);
+		idx = inc_idx(MAIN_LOG, idx);
 		seq++;
 		prev = msg->flags;
 	}
