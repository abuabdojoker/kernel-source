From: Petr Mladek <pmladek@suse.cz>
Date: Tue, 18 Feb 2014 15:56:43 +0100
Subject: [RFC PATCH 05/11] printk: allow to modify NMI log buffer size using boot
 parameter
Patch-mainline: Submitted https://lkml.org/lkml/2014/5/9/122
References: bnc#831949

pmladek@suse.cz:
This patch needed some modifications for SLED12 to avoid KABI changes:

+ there are used global variables instead of the struct printk_log


Having NMI log buffer of the same size as the main log buffer might
be considered as a waste of memory. Especially when the main buffer
is increased to a big value. So create a separate kernel parameters
to set nmi_log_buf_len.

Some users might want to avoid the buffer entirely. It can be done
by the zero value. In this case, the printk will stay safe in the
NMI context but there will be higher chance that some message could
get lost.

The maximum size is tested when the NMI log buffer is allocated. Note
that even the default size might be too big if there is not enough
bytes to store the index.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
---
 Documentation/kernel-parameters.txt |   19 +++++++++++++++++--
 kernel/printk/printk.c              |   22 +++++++++++++++++-----
 2 files changed, 34 insertions(+), 7 deletions(-)

--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -211,8 +211,9 @@ bytes respectively. Such letter suffixes
 			    acpi.debug_layer=0x2 acpi.debug_level=0xffffffff
 
 			Some values produce so much output that the system is
-			unusable.  The "log_buf_len" parameter may be useful
-			if you need to capture more output.
+			unusable.  The "log_buf_len" and "nmi_log_buf_len"
+			parameters may be useful if you need to capture more
+			output.
 
 	acpi_irq_balance [HW,ACPI]
 			ACPI will balance active IRQs
@@ -1966,6 +1967,20 @@ bytes respectively. Such letter suffixes
 			when a NMI is triggered.
 			Format: [state][,regs][,debounce][,die]
 
+	nmi_log_buf_len=n[KMG]	Sets the size of a helper ring buffer for
+			printk messages in NMI context. It is used only as
+			fallback when the lock for the main ring buffer is
+			already taken. The content is merged into the main
+			buffer when possible.
+
+			The size is in bytes and must be a power of two. The
+			default size is the same as for the main printk ring
+			buffer.
+
+			The size 0 can be used to disable the extra buffer
+			entirely. It saves space but there is a higher risk
+			that some messages will get lost.
+
 	nmi_watchdog=	[KNL,BUGS=X86] Debugging features for SMP kernels
 			Format: [panic,][nopanic,][num]
 			Valid num: 0
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1099,6 +1099,18 @@ static void __init log_buf_add_cpu(void)
 	log_buf_len_update(cpu_extra + __LOG_BUF_LEN);
 }
 
+/* NMI log buffer can be completely disabled by setting 0 value */
+static int __init nmi_log_buf_len_setup(char *str)
+{
+	nmi_log_buf_len = memparse(str, &str);
+
+	if (nmi_log_buf_len)
+		nmi_log_buf_len = roundup_pow_of_two(nmi_log_buf_len);
+
+	return 0;
+}
+early_param("nmi_log_buf_len", nmi_log_buf_len_setup);
+
 char * __init alloc_log_buf(int early, unsigned len)
 {
 	if (early) {
@@ -1120,13 +1132,13 @@ void __init setup_log_buf(int early)
 	int free;
 
 	if (!nmi_log_buf) {
-		/* use the same size that will be used for normal buffer */
-		if (new_log_buf_len > nmi_log_buf_len)
-			nmi_log_buf_len = new_log_buf_len;
 		if (nmi_log_buf_len > NMI_MAX_LEN)
 			nmi_log_buf_len = NMI_MAX_LEN;
-		nmi_log_buf = alloc_log_buf(early, nmi_log_buf_len);
-		if (!nmi_log_buf)
+		/* zero length means that the feature is disabled */
+		if (nmi_log_buf_len)
+			nmi_log_buf = alloc_log_buf(early, nmi_log_buf_len);
+
+		if (!nmi_log_buf && nmi_log_buf_len)
 			pr_err("%d bytes not available for NMI ring buffer\n",
 			       nmi_log_buf_len);
 		else
