From: Aurelien Aptel <aaptel@suse.com>
Subject: fs/cifs: fix wrongly prefixed path to root
Patch-mainline: Submitted, linux-cifs 2016-04-20
References: bsc#963655, bsc#979681

When cifs_get_root() calls cifs_build_path_to_root(), it expects a full
path from the root, even in the presence of a DFS link.

e.g. in the case of a DFS link like

    //A/shareA/link -> //B/shareB/sub/dir/

When mounting shareA and doing a "cd link", cifs_get_root() was getting

    "//B/shareB//sub/dir"

Instead of

    "/sub/dir"

Resulting in

    sh: cd: link: No such file or directory

--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -50,30 +50,15 @@ cifs_build_path_to_root(struct smb_vol *
 			struct cifs_tcon *tcon)
 {
 	int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;
-	int dfsplen;
 	char *full_path = NULL;
 
-	/* if no prefix path, simply set path to the root of share to "" */
-	if (pplen == 0) {
-		full_path = kzalloc(1, GFP_KERNEL);
-		return full_path;
-	}
-
-	if (tcon->Flags & SMB_SHARE_IS_IN_DFS)
-		dfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);
-	else
-		dfsplen = 0;
-
-	full_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);
+	full_path = kmalloc(pplen + 1, GFP_KERNEL);
 	if (full_path == NULL)
 		return full_path;
 
-	if (dfsplen)
-		strncpy(full_path, tcon->treeName, dfsplen);
-	full_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);
-	strncpy(full_path + dfsplen + 1, vol->prepath, pplen);
+	strncpy(full_path, vol->prepath, pplen);
 	convert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));
-	full_path[dfsplen + pplen] = 0; /* add trailing null */
+	full_path[pplen] = 0; /* add trailing null */
 	return full_path;
 }
 
