From: Keith Busch <keith.busch@intel.com>
Date: Fri, 12 Jun 2015 13:56:32 -0600
Subject: [PATCH] NVMe: Avoid infinite loop on broken device
Patch-mainline: Never, in nvme-legacy repository
Git-commit: 666dada2068f6d48f26c942a21c38fdd9f2d4b49
Git-repo: http://git.infradead.org/users/kbusch/nvme-legacy.git
References: bsc#948374

If the device fails to reset on initialization, assume it's dead and
remove it from the topology.

Signed-off-by: Keith Busch <keith.busch@intel.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/block/nvme-core.c |   37 +++++++++++++++++++++++--------------
 1 file changed, 23 insertions(+), 14 deletions(-)

--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -2961,10 +2961,23 @@ static int nvme_dev_resume(struct nvme_d
 		dev->reset_workfn = nvme_remove_disks;
 		queue_work(nvme_workq, &dev->reset_work);
 		spin_unlock(&dev_list_lock);
-	}
+	} else
+		nvme_dev_add(dev);
 	return 0;
 }
 
+static void nvme_dead_ctrl(struct nvme_dev *dev)
+{
+	dev_err(&dev->pci_dev->dev, "Device failed to resume\n");
+	kref_get(&dev->kref);
+	if (IS_ERR(kthread_run(nvme_remove_dead_ctrl, dev, "nvme%d",
+					dev->instance))) {
+		dev_err(&dev->pci_dev->dev,
+			"Failed to start controller remove task\n");
+		kref_put(&dev->kref, nvme_free_dev);
+	}
+}
+
 static void nvme_dev_reset(struct nvme_dev *dev)
 {
 	nvme_dev_shutdown(dev);
@@ -3103,23 +3116,19 @@ static int nvme_probe(struct pci_dev *pd
 static void nvme_async_probe(struct work_struct *work)
 {
 	struct nvme_dev *dev = container_of(work, struct nvme_dev, probe_work);
-	int result;
+	int ret = nvme_dev_resume(dev);
 
-	result = nvme_dev_start(dev);
-	if (result)
-		goto reset;
+	if (!ret)
+		return;
 
-	if (dev->online_queues > 1)
-		result = nvme_dev_add(dev);
-	if (result)
-		goto reset;
-
-	return;
- reset:
 	spin_lock(&dev_list_lock);
 	if (!work_busy(&dev->reset_work)) {
-		dev->reset_workfn = nvme_reset_failed_dev;
-		queue_work(nvme_workq, &dev->reset_work);
+		if (ret == -ENODEV)
+			nvme_dead_ctrl(dev);
+		else {
+			dev->reset_workfn = nvme_reset_failed_dev;
+			queue_work(nvme_workq, &dev->reset_work);
+		}
 	}
 	spin_unlock(&dev_list_lock);
 }
