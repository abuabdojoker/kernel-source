From: Michal Kubecek <mkubecek@suse.cz>
Date: Wed, 9 Mar 2016 09:44:27 +0100
Subject: kabi: protect struct netns_ipv6 after FIB6 GC series
Patch-mainline: Never, kabi workaround
References: bsc#965319

Backports of patches

  812918c464ec ("ipv6: make fib6 serial number per namespace")
  9a03cd8f38ef ("ipv6: per netns fib6 walkers")
  3dc94f93be16 ("ipv6: per netns FIB garbage collection")

add new members into struct netns_ipv6 which would break kABI as this
structure is embedded in struct net. Moving these new members to the end
of struct net and hiding them from genksyms should be safe as instances
of struct net should always be created using net_alloc() - or rather
copy_net_ns() as the former is static.

Using net_generic infrastructure would be cleaner but it would add some
overhead and resulting code would be less readable.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/net_namespace.h |    6 ++++++
 include/net/netns/ipv6.h    |    4 ----
 net/ipv6/ip6_fib.c          |   38 +++++++++++++++++++-------------------
 3 files changed, 25 insertions(+), 23 deletions(-)

--- a/include/net/net_namespace.h
+++ b/include/net/net_namespace.h
@@ -121,6 +121,12 @@ struct net {
 #endif
 	struct sock		*diag_nlsk;
 	atomic_t		fnhe_genid;
+#ifndef __GENKSYMS__
+	struct list_head	fib6_walkers;
+	rwlock_t		fib6_walker_lock;
+	spinlock_t		fib6_gc_lock;
+	__u32			fib6_sernum;
+#endif
 };
 
 /*
--- a/include/net/netns/ipv6.h
+++ b/include/net/netns/ipv6.h
@@ -50,12 +50,8 @@ struct netns_ipv6 {
 	struct timer_list       ip6_fib_timer;
 	struct hlist_head       *fib_table_hash;
 	struct fib6_table       *fib6_main_tbl;
-	struct list_head	fib6_walkers;
 	struct dst_ops		ip6_dst_ops;
-	rwlock_t		fib6_walker_lock;
-	spinlock_t		fib6_gc_lock;
 	unsigned int		 ip6_rt_gc_expire;
-	__u32			fib6_sernum;
 	unsigned long		 ip6_rt_last_gc;
 #ifdef CONFIG_IPV6_MULTIPLE_TABLES
 	struct rt6_info         *ip6_prohibit_entry;
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -90,26 +90,26 @@ static int fib6_walk_continue(struct fib
 static void fib6_gc_timer_cb(unsigned long arg);
 
 #define FOR_WALKERS(net, w) \
-	list_for_each_entry(w, &(net)->ipv6.fib6_walkers, lh)
+	list_for_each_entry(w, &(net)->fib6_walkers, lh)
 
 static inline void fib6_walker_link(struct net *net, struct fib6_walker_t *w)
 {
-	write_lock_bh(&net->ipv6.fib6_walker_lock);
-	list_add(&w->lh, &net->ipv6.fib6_walkers);
-	write_unlock_bh(&net->ipv6.fib6_walker_lock);
+	write_lock_bh(&net->fib6_walker_lock);
+	list_add(&w->lh, &net->fib6_walkers);
+	write_unlock_bh(&net->fib6_walker_lock);
 }
 
 static inline void fib6_walker_unlink(struct net *net, struct fib6_walker_t *w)
 {
-	write_lock_bh(&net->ipv6.fib6_walker_lock);
+	write_lock_bh(&net->fib6_walker_lock);
 	list_del(&w->lh);
-	write_unlock_bh(&net->ipv6.fib6_walker_lock);
+	write_unlock_bh(&net->fib6_walker_lock);
 }
 static __inline__ u32 fib6_new_sernum(struct net *net)
 {
-	u32 n = ++(net->ipv6.fib6_sernum);
+	u32 n = ++(net->fib6_sernum);
 	if ((__s32)n <= 0)
-		net->ipv6.fib6_sernum = n = 1;
+		net->fib6_sernum = n = 1;
 	return n;
 }
 
@@ -1294,7 +1294,7 @@ static struct fib6_node *fib6_repair_tre
 		}
 #endif
 
-		read_lock(&net->ipv6.fib6_walker_lock);
+		read_lock(&net->fib6_walker_lock);
 		FOR_WALKERS(net, w) {
 			if (!child) {
 				if (w->root == fn) {
@@ -1322,7 +1322,7 @@ static struct fib6_node *fib6_repair_tre
 				}
 			}
 		}
-		read_unlock(&net->ipv6.fib6_walker_lock);
+		read_unlock(&net->fib6_walker_lock);
 
 		node_free(fn);
 		if (pn->fn_flags & RTN_RTINFO || FIB6_SUBTREE(pn))
@@ -1365,7 +1365,7 @@ static void fib6_del_route(struct fib6_n
 	}
 
 	/* Adjust walkers */
-	read_lock(&net->ipv6.fib6_walker_lock);
+	read_lock(&net->fib6_walker_lock);
 	FOR_WALKERS(net, w) {
 		if (w->state == FWS_C && w->leaf == rt) {
 			RT6_TRACE("walker %p adjusted by delroute\n", w);
@@ -1374,7 +1374,7 @@ static void fib6_del_route(struct fib6_n
 				w->state = FWS_U;
 		}
 	}
-	read_unlock(&net->ipv6.fib6_walker_lock);
+	read_unlock(&net->fib6_walker_lock);
 
 	rt->dst.rt6_next = NULL;
 
@@ -1730,8 +1730,8 @@ void fib6_run_gc(unsigned long expires,
 	unsigned long now;
 
 	if (force) {
-		spin_lock_bh(&net->ipv6.fib6_gc_lock);
-	} else if (!spin_trylock_bh(&net->ipv6.fib6_gc_lock)) {
+		spin_lock_bh(&net->fib6_gc_lock);
+	} else if (!spin_trylock_bh(&net->fib6_gc_lock)) {
 		mod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);
 		return;
 	}
@@ -1750,7 +1750,7 @@ void fib6_run_gc(unsigned long expires,
 					+ net->ipv6.sysctl.ip6_rt_gc_interval));
 	else
 		del_timer(&net->ipv6.ip6_fib_timer);
-	spin_unlock_bh(&net->ipv6.fib6_gc_lock);
+	spin_unlock_bh(&net->fib6_gc_lock);
 }
 
 static void fib6_gc_timer_cb(unsigned long arg)
@@ -1762,10 +1762,10 @@ static int __net_init fib6_net_init(stru
 {
 	size_t size = sizeof(struct hlist_head) * FIB6_TABLE_HASHSZ;
 
-	net->ipv6.fib6_sernum = 1;
-	spin_lock_init(&net->ipv6.fib6_gc_lock);
-	rwlock_init(&net->ipv6.fib6_walker_lock);
-	INIT_LIST_HEAD(&net->ipv6.fib6_walkers);
+	net->fib6_sernum = 1;
+	spin_lock_init(&net->fib6_gc_lock);
+	rwlock_init(&net->fib6_walker_lock);
+	INIT_LIST_HEAD(&net->fib6_walkers);
 	setup_timer(&net->ipv6.ip6_fib_timer, fib6_gc_timer_cb, (unsigned long)net);
 
 	net->ipv6.rt6_stats = kzalloc(sizeof(*net->ipv6.rt6_stats), GFP_KERNEL);
