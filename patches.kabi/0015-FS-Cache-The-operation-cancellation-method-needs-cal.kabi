From: NeilBrown <neilb@suse.com>
Subject: Fix kabi issue
Patch-mainline: never, kabi
References: bsc#971049

Not sure why some of this is exported, but it is so ....

Fortunately only one 'cancel' function is ever used so a gross hack is
sufficient to call it at the right time.

Acked-by: NeilBrown <neilb@suse.com>
Signed-off-by: Neil Brown <neilb@suse.com>

---
 fs/fscache/cookie.c           |    2 +-
 fs/fscache/object.c           |    3 +--
 fs/fscache/operation.c        |   34 ++++++++++++++++++----------------
 fs/fscache/page.c             |   12 +++++-------
 include/linux/fscache-cache.h |    5 -----
 5 files changed, 25 insertions(+), 31 deletions(-)

--- a/fs/fscache/cookie.c
+++ b/fs/fscache/cookie.c
@@ -585,7 +585,7 @@ int __fscache_check_consistency(struct f
 	if (!op)
 		return -ENOMEM;
 
-	fscache_operation_init(op, NULL, NULL, NULL);
+	fscache_operation_init(op, NULL, NULL);
 	op->flags = FSCACHE_OP_MYTHREAD |
 		(1 << FSCACHE_OP_WAITING) |
 		(1 << FSCACHE_OP_UNUSE_COOKIE);
--- a/fs/fscache/object.c
+++ b/fs/fscache/object.c
@@ -958,8 +958,7 @@ static const struct fscache_state *_fsca
 	if (!op)
 		goto nomem;
 
-	fscache_operation_init(op, object->cache->ops->invalidate_object,
-			       NULL, NULL);
+	fscache_operation_init(op, object->cache->ops->invalidate_object, NULL);
 	op->flags = FSCACHE_OP_ASYNC |
 		(1 << FSCACHE_OP_EXCLUSIVE) |
 		(1 << FSCACHE_OP_UNUSE_COOKIE);
--- a/fs/fscache/operation.c
+++ b/fs/fscache/operation.c
@@ -20,10 +20,14 @@
 atomic_t fscache_op_debug_id;
 EXPORT_SYMBOL(fscache_op_debug_id);
 
-static void fscache_operation_dummy_cancel(struct fscache_operation *op)
+void fscache_release_retrieval_op(struct fscache_operation *_op);
+void fscache_do_cancel_retrieval(struct fscache_operation *_op);
+
+static inline void do_cancel(struct fscache_operation *op)
 {
+	if (op->release == fscache_release_retrieval_op)
+		fscache_do_cancel_retrieval(op);
 }
-
 /**
  * fscache_operation_init - Do basic initialisation of an operation
  * @op: The operation to initialise
@@ -34,7 +38,6 @@ static void fscache_operation_dummy_canc
  */
 void fscache_operation_init(struct fscache_operation *op,
 			    fscache_operation_processor_t processor,
-			    fscache_operation_cancel_t cancel,
 			    fscache_operation_release_t release)
 {
 	INIT_WORK(&op->work, fscache_op_work_func);
@@ -42,7 +45,6 @@ void fscache_operation_init(struct fscac
 	op->state = FSCACHE_OP_ST_INITIALISED;
 	op->debug_id = atomic_inc_return(&fscache_op_debug_id);
 	op->processor = processor;
-	op->cancel = cancel ?: fscache_operation_dummy_cancel;
 	op->release = release;
 	INIT_LIST_HEAD(&op->pend_link);
 }
@@ -170,11 +172,11 @@ int fscache_submit_exclusive_op(struct f
 	flags = READ_ONCE(object->flags);
 	if (unlikely(!(flags & BIT(FSCACHE_OBJECT_IS_LIVE)))) {
 		fscache_stat(&fscache_n_op_rejected);
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -ENOBUFS;
 	} else if (unlikely(fscache_cache_is_broken(object))) {
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -EIO;
 	} else if (flags & BIT(FSCACHE_OBJECT_IS_AVAILABLE)) {
@@ -208,12 +210,12 @@ int fscache_submit_exclusive_op(struct f
 		fscache_stat(&fscache_n_op_pend);
 		ret = 0;
 	} else if (flags & BIT(FSCACHE_OBJECT_KILLED_BY_CACHE)) {
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -ENOBUFS;
 	} else {
 		fscache_report_unexpected_submission(object, op, ostate);
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -ENOBUFS;
 	}
@@ -255,11 +257,11 @@ int fscache_submit_op(struct fscache_obj
 	flags = READ_ONCE(object->flags);
 	if (unlikely(!(flags & BIT(FSCACHE_OBJECT_IS_LIVE)))) {
 		fscache_stat(&fscache_n_op_rejected);
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -ENOBUFS;
 	} else if (unlikely(fscache_cache_is_broken(object))) {
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -EIO;
 	} else if (flags & BIT(FSCACHE_OBJECT_IS_AVAILABLE)) {
@@ -288,13 +290,13 @@ int fscache_submit_op(struct fscache_obj
 		fscache_stat(&fscache_n_op_pend);
 		ret = 0;
 	} else if (flags & BIT(FSCACHE_OBJECT_KILLED_BY_CACHE)) {
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -ENOBUFS;
 	} else {
 		fscache_report_unexpected_submission(object, op, ostate);
 		ASSERT(!fscache_object_is_active(object));
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		ret = -ENOBUFS;
 	}
@@ -370,7 +372,7 @@ int fscache_cancel_op(struct fscache_ope
 		put = true;
 
 		fscache_stat(&fscache_n_op_cancelled);
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))
 			object->n_exclusive--;
@@ -386,7 +388,7 @@ int fscache_cancel_op(struct fscache_ope
 			fscache_start_operations(object);
 
 		fscache_stat(&fscache_n_op_cancelled);
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 		if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))
 			object->n_exclusive--;
@@ -420,7 +422,7 @@ void fscache_cancel_all_ops(struct fscac
 		list_del_init(&op->pend_link);
 
 		ASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 
 		if (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))
@@ -456,7 +458,7 @@ void fscache_op_complete(struct fscache_
 	if (!cancelled) {
 		op->state = FSCACHE_OP_ST_COMPLETE;
 	} else {
-		op->cancel(op);
+		do_cancel(op);
 		op->state = FSCACHE_OP_ST_CANCELLED;
 	}
 
--- a/fs/fscache/page.c
+++ b/fs/fscache/page.c
@@ -214,7 +214,7 @@ int __fscache_attr_changed(struct fscach
 		return -ENOMEM;
 	}
 
-	fscache_operation_init(op, fscache_attr_changed_op, NULL, NULL);
+	fscache_operation_init(op, fscache_attr_changed_op, NULL);
 	op->flags = FSCACHE_OP_ASYNC | (1 << FSCACHE_OP_EXCLUSIVE);
 
 	spin_lock(&cookie->lock);
@@ -244,7 +244,7 @@ EXPORT_SYMBOL(__fscache_attr_changed);
 /*
  * Handle cancellation of a pending retrieval op
  */
-static void fscache_do_cancel_retrieval(struct fscache_operation *_op)
+void fscache_do_cancel_retrieval(struct fscache_operation *_op)
 {
 	struct fscache_retrieval *op =
 		container_of(_op, struct fscache_retrieval, op);
@@ -255,7 +255,7 @@ static void fscache_do_cancel_retrieval(
 /*
  * release a retrieval op reference
  */
-static void fscache_release_retrieval_op(struct fscache_operation *_op)
+void fscache_release_retrieval_op(struct fscache_operation *_op)
 {
 	struct fscache_retrieval *op =
 		container_of(_op, struct fscache_retrieval, op);
@@ -289,9 +289,7 @@ static struct fscache_retrieval *fscache
 		return NULL;
 	}
 
-	fscache_operation_init(&op->op, NULL,
-			       fscache_do_cancel_retrieval,
-			       fscache_release_retrieval_op);
+	fscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);
 	atomic_inc(&cookie->n_active);
 	op->op.flags	= FSCACHE_OP_MYTHREAD |
 		(1UL << FSCACHE_OP_WAITING) |
@@ -923,7 +921,7 @@ int __fscache_write_page(struct fscache_
 	if (!op)
 		goto nomem;
 
-	fscache_operation_init(&op->op, fscache_write_op, NULL,
+	fscache_operation_init(&op->op, fscache_write_op,
 			       fscache_release_write_op);
 	op->op.flags = FSCACHE_OP_ASYNC |
 		(1 << FSCACHE_OP_WAITING) |
--- a/include/linux/fscache-cache.h
+++ b/include/linux/fscache-cache.h
@@ -74,7 +74,6 @@ extern wait_queue_head_t fscache_cache_c
  */
 typedef void (*fscache_operation_release_t)(struct fscache_operation *op);
 typedef void (*fscache_operation_processor_t)(struct fscache_operation *op);
-typedef void (*fscache_operation_cancel_t)(struct fscache_operation *op);
 
 enum fscache_operation_state {
 	FSCACHE_OP_ST_BLANK,		/* Op is not yet submitted */
@@ -110,9 +109,6 @@ struct fscache_operation {
 	 *   the op in a non-pool thread */
 	fscache_operation_processor_t processor;
 
-	/* Operation cancellation cleanup (optional) */
-	fscache_operation_cancel_t cancel;
-
 	/* operation releaser */
 	fscache_operation_release_t release;
 };
@@ -125,7 +121,6 @@ extern void fscache_op_complete(struct f
 extern void fscache_put_operation(struct fscache_operation *);
 extern void fscache_operation_init(struct fscache_operation *,
 				   fscache_operation_processor_t,
-				   fscache_operation_cancel_t,
 				   fscache_operation_release_t);
 
 /*
