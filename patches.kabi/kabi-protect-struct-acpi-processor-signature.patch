From: Joerg Roedel <jroedel@suse.de>
Subject: kabi: protect struct acpi_processor signature
Patch-mainline: Never, kabi workaround
References: bsc#959463

For bsc#959463, two commits are backported that break kabi. Commit
ca9f62ac783bf88c54143f8065adc0fc8df859c1 adds the field "apic_id" to struct
acpi_processor, and commit d536bf3dc97417471e2c5098837a1cddd7fbb3c7 changes
the signature of exported function acpi_map_lsapic().

The apic_id field stores the result of acpi_get_apicid(). The modified
acpi_map_lsapic() accepts this field as a new paramter instead of duplicating
the _MAT evaluation.  According to Fujitsu (bsc#959463 comment 14) the
duplicated evaluation is wrong on systems with x2apic strucure and breaks CPU
hot-add (the fact that it fixes a bug wasn't known at the time of the original
commit).

To handle this without breaking KABI, we create a acpi_map_lsapic2() variant
that keeps the new parameter, and use it from the CPU hot-add function
acpi_processor_hotadd_init(). Since we don't have the apic_id field, the
function calls acpi_get_apicid(). For that it has to add a new parameter for
device declaration, but the function is internal.

We restore acpi_map_lsapic() to omit the new parameter, and restore the
duplicated _MAT evaluation code. This is only for compatibility with any
out-of-tree modules that depend on this function (if such exist), and if it
keeps the buggy behavior, it's not a regression.

[vbabka@suse.cz: some tweaks, commit log]
Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
---
 arch/ia64/kernel/acpi.c       |   50 +++++++++++++++++++++++++++++++++++++++---
 arch/x86/kernel/acpi/boot.c   |   50 +++++++++++++++++++++++++++++++++++++++---
 drivers/acpi/acpi_processor.c |   14 +++++------
 include/acpi/processor.h      |    1 
 include/linux/acpi.h          |    3 +-
 5 files changed, 103 insertions(+), 15 deletions(-)

--- a/arch/ia64/kernel/acpi.c
+++ b/arch/ia64/kernel/acpi.c
@@ -882,7 +882,7 @@ __init void prefill_possible_map(void)
 		set_cpu_possible(i, true);
 }
 
-static int _acpi_map_lsapic(acpi_handle handle, int physid, int *pcpu)
+static int _acpi_map_lsapic2(acpi_handle handle, int physid, int *pcpu)
 {
 	cpumask_t tmp_map;
 	int cpu;
@@ -903,13 +903,57 @@ static int _acpi_map_lsapic(acpi_handle
 	return (0);
 }
 
+static int _acpi_map_lsapic(acpi_handle handle, int *pcpu)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	struct acpi_madt_local_sapic *lsapic;
+	cpumask_t tmp_map;
+	int physid;
+
+	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_MAT", NULL, &buffer)))
+		return -EINVAL;
+
+	if (!buffer.length || !buffer.pointer)
+		return -EINVAL;
+
+	obj = buffer.pointer;
+	if (obj->type != ACPI_TYPE_BUFFER)
+	{
+		kfree(buffer.pointer);
+		return -EINVAL;
+	}
+
+	lsapic = (struct acpi_madt_local_sapic *)obj->buffer.pointer;
+
+	if ((lsapic->header.type != ACPI_MADT_TYPE_LOCAL_SAPIC) ||
+	    (!(lsapic->lapic_flags & ACPI_MADT_ENABLED))) {
+		kfree(buffer.pointer);
+		return -EINVAL;
+	}
+
+	physid = ((lsapic->id << 8) | (lsapic->eid));
+
+	kfree(buffer.pointer);
+	buffer.length = ACPI_ALLOCATE_BUFFER;
+	buffer.pointer = NULL;
+
+	return _acpi_map_lsapic2(handle, physid, pcpu);
+}
+
 /* wrapper to silence section mismatch warning */
-int __ref acpi_map_lsapic(acpi_handle handle, int physid, int *pcpu)
+int __ref acpi_map_lsapic(acpi_handle handle, int *pcpu)
 {
-	return _acpi_map_lsapic(handle, physid, pcpu);
+	return _acpi_map_lsapic(handle, pcpu);
 }
 EXPORT_SYMBOL(acpi_map_lsapic);
 
+int __ref acpi_map_lsapic2(acpi_handle handle, int physid, int *pcpu)
+{
+	return _acpi_map_lsapic2(handle, physid, pcpu);
+}
+EXPORT_SYMBOL(acpi_map_lsapic2);
+
 int acpi_unmap_lsapic(int cpu)
 {
 	ia64_cpu_to_sapicid[cpu] = -1;
--- a/arch/x86/kernel/acpi/boot.c
+++ b/arch/x86/kernel/acpi/boot.c
@@ -614,7 +614,7 @@ static void acpi_map_cpu2node(acpi_handl
 #endif
 }
 
-static int _acpi_map_lsapic(acpi_handle handle, int physid, int *pcpu)
+static int _acpi_map_lsapic2(acpi_handle handle, int physid, int *pcpu)
 {
 	cpumask_var_t tmp_map, new_map;
 	int cpu;
@@ -656,10 +656,54 @@ out:
 	return retval;
 }
 
+static int _acpi_map_lsapic(acpi_handle handle, int *pcpu)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	struct acpi_madt_local_apic *lapic;
+	u8 physid;
+
+	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_MAT", NULL, &buffer)))
+		return -EINVAL;
+
+	if (!buffer.length || !buffer.pointer)
+		return -EINVAL;
+
+	obj = buffer.pointer;
+	if (obj->type != ACPI_TYPE_BUFFER ||
+			obj->buffer.length < sizeof(*lapic)) {
+		kfree(buffer.pointer);
+		return -EINVAL;
+	}
+
+	lapic = (struct acpi_madt_local_apic *)obj->buffer.pointer;
+
+	if (lapic->header.type != ACPI_MADT_TYPE_LOCAL_APIC ||
+			!(lapic->lapic_flags & ACPI_MADT_ENABLED)) {
+		kfree(buffer.pointer);
+		return -EINVAL;
+	}
+
+	physid = lapic->id;
+
+	kfree(buffer.pointer);
+	buffer.length = ACPI_ALLOCATE_BUFFER;
+	buffer.pointer = NULL;
+	lapic = NULL;
+
+	return _acpi_map_lsapic2(handle, physid, pcpu);
+}
+
+int __ref acpi_map_lsapic2(acpi_handle handle, int physid, int *pcpu)
+{
+	return _acpi_map_lsapic2(handle, physid, pcpu);
+}
+EXPORT_SYMBOL(acpi_map_lsapic2);
+
 /* wrapper to silence section mismatch warning */
-int __ref acpi_map_lsapic(acpi_handle handle, int physid, int *pcpu)
+int __ref acpi_map_lsapic(acpi_handle handle, int *pcpu)
 {
-	return _acpi_map_lsapic(handle, physid, pcpu);
+	return _acpi_map_lsapic(handle, pcpu);
 }
 EXPORT_SYMBOL(acpi_map_lsapic);
 
--- a/drivers/acpi/acpi_processor.c
+++ b/drivers/acpi/acpi_processor.c
@@ -168,7 +168,7 @@ static int acpi_processor_errata(struct
    -------------------------------------------------------------------------- */
 
 #ifdef CONFIG_ACPI_HOTPLUG_CPU
-static int acpi_processor_hotadd_init(struct acpi_processor *pr)
+static int acpi_processor_hotadd_init(struct acpi_processor *pr, int dd)
 {
 	unsigned long long sta;
 	acpi_status status;
@@ -181,7 +181,9 @@ static int acpi_processor_hotadd_init(st
 	cpu_maps_update_begin();
 	cpu_hotplug_begin();
 
-	ret = acpi_map_lsapic(pr->handle, pr->apic_id, &pr->id);
+	ret = acpi_map_lsapic2(pr->handle,
+			       acpi_get_apicid(pr->handle, dd, pr->acpi_id),
+			       &pr->id);
 	if (ret)
 		goto out;
 
@@ -205,7 +207,7 @@ out:
 	return ret;
 }
 #else
-static inline int acpi_processor_hotadd_init(struct acpi_processor *pr)
+static inline int acpi_processor_hotadd_init(struct acpi_processor *pr, int dd)
 {
 	return -ENODEV;
 }
@@ -270,9 +272,7 @@ static int acpi_processor_get_info(struc
 		device_declaration = 1;
 		pr->acpi_id = value;
 	}
-	pr->apic_id = acpi_get_apicid(pr->handle, device_declaration,
-					pr->acpi_id);
-	cpu_index = acpi_map_cpuid(pr->apic_id, pr->acpi_id);
+	cpu_index = acpi_get_cpuid(pr->handle, device_declaration, pr->acpi_id);
 
 	/* Handle UP system running SMP kernel, with no LAPIC in MADT */
 	if (!cpu0_initialized && (cpu_index == -1) &&
@@ -290,7 +290,7 @@ static int acpi_processor_get_info(struc
 	 *  they are physically not present.
 	 */
 	if (pr->id == -1) {
-		int ret = acpi_processor_hotadd_init(pr);
+		int ret = acpi_processor_hotadd_init(pr, device_declaration);
 		if (ret)
 			return ret;
 	}
--- a/include/acpi/processor.h
+++ b/include/acpi/processor.h
@@ -199,7 +199,6 @@ struct acpi_processor_flags {
 struct acpi_processor {
 	acpi_handle handle;
 	u32 acpi_id;
-	u32 apic_id;
 	u32 id;
 	u32 pblk;
 	int performance_platform_limit;
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -125,7 +125,8 @@ void acpi_numa_arch_fixup(void);
 
 #ifdef CONFIG_ACPI_HOTPLUG_CPU
 /* Arch dependent functions for cpu hotplug support */
-int acpi_map_lsapic(acpi_handle handle, int physid, int *pcpu);
+int acpi_map_lsapic(acpi_handle handle, int *pcpu);
+int acpi_map_lsapic2(acpi_handle handle, int physid, int *pcpu);
 int acpi_unmap_lsapic(int cpu);
 #endif /* CONFIG_ACPI_HOTPLUG_CPU */
 
